"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/weak-map";
exports.ids = ["vendor-chunks/weak-map"];
exports.modules = {

/***/ "(rsc)/../../node_modules/weak-map/weak-map.js":
/*!***********************************************!*\
  !*** ../../node_modules/weak-map/weak-map.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n// Copyright (C) 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @fileoverview Install a leaky WeakMap emulation on platforms that\n * don't provide a built-in one.\n *\n * <p>Assumes that an ES5 platform where, if {@code WeakMap} is\n * already present, then it conforms to the anticipated ES6\n * specification. To run this file on an ES5 or almost ES5\n * implementation where the {@code WeakMap} specification does not\n * quite conform, run <code>repairES5.js</code> first.\n *\n * <p>Even though WeakMapModule is not global, the linter thinks it\n * is, which is why it is in the overrides list below.\n *\n * <p>NOTE: Before using this WeakMap emulation in a non-SES\n * environment, see the note below about hiddenRecord.\n *\n * @author Mark S. Miller\n * @requires crypto, ArrayBuffer, Uint8Array, navigator, console\n * @overrides WeakMap, ses, Proxy\n * @overrides WeakMapModule\n */ /**\n * This {@code WeakMap} emulation is observably equivalent to the\n * ES-Harmony WeakMap, but with leakier garbage collection properties.\n *\n * <p>As with true WeakMaps, in this emulation, a key does not\n * retain maps indexed by that key and (crucially) a map does not\n * retain the keys it indexes. A map by itself also does not retain\n * the values associated with that map.\n *\n * <p>However, the values associated with a key in some map are\n * retained so long as that key is retained and those associations are\n * not overridden. For example, when used to support membranes, all\n * values exported from a given membrane will live for the lifetime\n * they would have had in the absence of an interposed membrane. Even\n * when the membrane is revoked, all objects that would have been\n * reachable in the absence of revocation will still be reachable, as\n * far as the GC can tell, even though they will no longer be relevant\n * to ongoing computation.\n *\n * <p>The API implemented here is approximately the API as implemented\n * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,\n * rather than the offially approved proposal page. TODO(erights):\n * upgrade the ecmascript WeakMap proposal page to explain this API\n * change and present to EcmaScript committee for their approval.\n *\n * <p>The first difference between the emulation here and that in\n * FF6.0a1 is the presence of non enumerable {@code get___, has___,\n * set___, and delete___} methods on WeakMap instances to represent\n * what would be the hidden internal properties of a primitive\n * implementation. Whereas the FF6.0a1 WeakMap.prototype methods\n * require their {@code this} to be a genuine WeakMap instance (i.e.,\n * an object of {@code [[Class]]} \"WeakMap}), since there is nothing\n * unforgeable about the pseudo-internal method names used here,\n * nothing prevents these emulated prototype methods from being\n * applied to non-WeakMaps with pseudo-internal methods of the same\n * names.\n *\n * <p>Another difference is that our emulated {@code\n * WeakMap.prototype} is not itself a WeakMap. A problem with the\n * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap\n * providing ambient mutability and an ambient communications\n * channel. Thus, if a WeakMap is already present and has this\n * problem, repairES5.js wraps it in a safe wrappper in order to\n * prevent access to this channel. (See\n * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).\n */ /**\n * If this is a full <a href=\n * \"http://code.google.com/p/es-lab/wiki/SecureableES5\"\n * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is\n * absent, install an approximate emulation.\n *\n * <p>If WeakMap is present but cannot store some objects, use our approximate\n * emulation as a wrapper.\n *\n * <p>If this is almost a secureable ES5 platform, then WeakMap.js\n * should be run after repairES5.js.\n *\n * <p>See {@code WeakMap} for documentation of the garbage collection\n * properties of this WeakMap emulation.\n */ (function WeakMapModule() {\n    \"use strict\";\n    if (typeof ses !== \"undefined\" && ses.ok && !ses.ok()) {\n        // already too broken, so give up\n        return;\n    }\n    /**\n   * In some cases (current Firefox), we must make a choice betweeen a\n   * WeakMap which is capable of using all varieties of host objects as\n   * keys and one which is capable of safely using proxies as keys. See\n   * comments below about HostWeakMap and DoubleWeakMap for details.\n   *\n   * This function (which is a global, not exposed to guests) marks a\n   * WeakMap as permitted to do what is necessary to index all host\n   * objects, at the cost of making it unsafe for proxies.\n   *\n   * Do not apply this function to anything which is not a genuine\n   * fresh WeakMap.\n   */ function weakMapPermitHostObjects(map) {\n        // identity of function used as a secret -- good enough and cheap\n        if (map.permitHostObjects___) {\n            map.permitHostObjects___(weakMapPermitHostObjects);\n        }\n    }\n    if (typeof ses !== \"undefined\") {\n        ses.weakMapPermitHostObjects = weakMapPermitHostObjects;\n    }\n    // IE 11 has no Proxy but has a broken WeakMap such that we need to patch\n    // it using DoubleWeakMap; this flag tells DoubleWeakMap so.\n    var doubleWeakMapCheckSilentFailure = false;\n    // Check if there is already a good-enough WeakMap implementation, and if so\n    // exit without replacing it.\n    if (typeof WeakMap === \"function\") {\n        var HostWeakMap = WeakMap;\n        // There is a WeakMap -- is it good enough?\n        if (typeof navigator !== \"undefined\" && /Firefox/.test(navigator.userAgent)) {\n        // We're now *assuming not*, because as of this writing (2013-05-06)\n        // Firefox's WeakMaps have a miscellany of objects they won't accept, and\n        // we don't want to make an exhaustive list, and testing for just one\n        // will be a problem if that one is fixed alone (as they did for Event).\n        // If there is a platform that we *can* reliably test on, here's how to\n        // do it:\n        //  var problematic = ... ;\n        //  var testHostMap = new HostWeakMap();\n        //  try {\n        //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here\n        //    if (testHostMap.get(problematic) === 1) {\n        //      return;\n        //    }\n        //  } catch (e) {}\n        } else {\n            // IE 11 bug: WeakMaps silently fail to store frozen objects.\n            var testMap = new HostWeakMap();\n            var testObject = Object.freeze({});\n            testMap.set(testObject, 1);\n            if (testMap.get(testObject) !== 1) {\n                doubleWeakMapCheckSilentFailure = true;\n            // Fall through to installing our WeakMap.\n            } else {\n                module.exports = WeakMap;\n                return;\n            }\n        }\n    }\n    var hop = Object.prototype.hasOwnProperty;\n    var gopn = Object.getOwnPropertyNames;\n    var defProp = Object.defineProperty;\n    var isExtensible = Object.isExtensible;\n    /**\n   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and\n   * <i>undiscoverable</i> by untrusted code.\n   *\n   * <p>Given the known weaknesses of Math.random() on existing\n   * browsers, it does not generate unguessability we can be confident\n   * of.\n   *\n   * <p>It is the monkey patching logic in this file that is intended\n   * to ensure undiscoverability. The basic idea is that there are\n   * three fundamental means of discovering properties of an object:\n   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),\n   * as well as some proposed ES6 extensions that appear on our\n   * whitelist. The first two only discover enumerable properties, and\n   * we only use HIDDEN_NAME to name a non-enumerable property, so the\n   * only remaining threat should be getOwnPropertyNames and some\n   * proposed ES6 extensions that appear on our whitelist. We monkey\n   * patch them to remove HIDDEN_NAME from the list of properties they\n   * returns.\n   *\n   * <p>TODO(erights): On a platform with built-in Proxies, proxies\n   * could be used to trap and thereby discover the HIDDEN_NAME, so we\n   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in\n   * order to wrap the provided handler with the real handler which\n   * filters out all traps using HIDDEN_NAME.\n   *\n   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an\n   * encapsulated function at a not-necessarily-secret name, which\n   * uses the Stiegler shared-state rights amplification pattern to\n   * reveal the associated value only to the WeakMap in which this key\n   * is associated with that value. Since only the key retains the\n   * function, the function can also remember the key without causing\n   * leakage of the key, so this doesn't violate our general gc\n   * goals. In addition, because the name need not be a guarded\n   * secret, we could efficiently handle cross-frame frozen keys.\n   */ var HIDDEN_NAME_PREFIX = \"weakmap:\";\n    var HIDDEN_NAME = HIDDEN_NAME_PREFIX + \"ident:\" + Math.random() + \"___\";\n    if (typeof crypto !== \"undefined\" && typeof crypto.getRandomValues === \"function\" && typeof ArrayBuffer === \"function\" && typeof Uint8Array === \"function\") {\n        var ab = new ArrayBuffer(25);\n        var u8s = new Uint8Array(ab);\n        crypto.getRandomValues(u8s);\n        HIDDEN_NAME = HIDDEN_NAME_PREFIX + \"rand:\" + Array.prototype.map.call(u8s, function(u8) {\n            return (u8 % 36).toString(36);\n        }).join(\"\") + \"___\";\n    }\n    function isNotHiddenName(name) {\n        return !(name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX && name.substr(name.length - 3) === \"___\");\n    }\n    /**\n   * Monkey patch getOwnPropertyNames to avoid revealing the\n   * HIDDEN_NAME.\n   *\n   * <p>The ES5.1 spec requires each name to appear only once, but as\n   * of this writing, this requirement is controversial for ES6, so we\n   * made this code robust against this case. If the resulting extra\n   * search turns out to be expensive, we can probably relax this once\n   * ES6 is adequately supported on all major browsers, iff no browser\n   * versions we support at that time have relaxed this constraint\n   * without providing built-in ES6 WeakMaps.\n   */ defProp(Object, \"getOwnPropertyNames\", {\n        value: function fakeGetOwnPropertyNames(obj) {\n            return gopn(obj).filter(isNotHiddenName);\n        }\n    });\n    /**\n   * getPropertyNames is not in ES5 but it is proposed for ES6 and\n   * does appear in our whitelist, so we need to clean it too.\n   */ if (\"getPropertyNames\" in Object) {\n        var originalGetPropertyNames = Object.getPropertyNames;\n        defProp(Object, \"getPropertyNames\", {\n            value: function fakeGetPropertyNames(obj) {\n                return originalGetPropertyNames(obj).filter(isNotHiddenName);\n            }\n        });\n    }\n    /**\n   * <p>To treat objects as identity-keys with reasonable efficiency\n   * on ES5 by itself (i.e., without any object-keyed collections), we\n   * need to add a hidden property to such key objects when we\n   * can. This raises several issues:\n   * <ul>\n   * <li>Arranging to add this property to objects before we lose the\n   *     chance, and\n   * <li>Hiding the existence of this new property from most\n   *     JavaScript code.\n   * <li>Preventing <i>certification theft</i>, where one object is\n   *     created falsely claiming to be the key of an association\n   *     actually keyed by another object.\n   * <li>Preventing <i>value theft</i>, where untrusted code with\n   *     access to a key object but not a weak map nevertheless\n   *     obtains access to the value associated with that key in that\n   *     weak map.\n   * </ul>\n   * We do so by\n   * <ul>\n   * <li>Making the name of the hidden property unguessable, so \"[]\"\n   *     indexing, which we cannot intercept, cannot be used to access\n   *     a property without knowing the name.\n   * <li>Making the hidden property non-enumerable, so we need not\n   *     worry about for-in loops or {@code Object.keys},\n   * <li>monkey patching those reflective methods that would\n   *     prevent extensions, to add this hidden property first,\n   * <li>monkey patching those methods that would reveal this\n   *     hidden property.\n   * </ul>\n   * Unfortunately, because of same-origin iframes, we cannot reliably\n   * add this hidden property before an object becomes\n   * non-extensible. Instead, if we encounter a non-extensible object\n   * without a hidden record that we can detect (whether or not it has\n   * a hidden record stored under a name secret to us), then we just\n   * use the key object itself to represent its identity in a brute\n   * force leaky map stored in the weak map, losing all the advantages\n   * of weakness for these.\n   */ function getHiddenRecord(key) {\n        if (key !== Object(key)) {\n            throw new TypeError(\"Not an object: \" + key);\n        }\n        var hiddenRecord = key[HIDDEN_NAME];\n        if (hiddenRecord && hiddenRecord.key === key) {\n            return hiddenRecord;\n        }\n        if (!isExtensible(key)) {\n            // Weak map must brute force, as explained in doc-comment above.\n            return void 0;\n        }\n        // The hiddenRecord and the key point directly at each other, via\n        // the \"key\" and HIDDEN_NAME properties respectively. The key\n        // field is for quickly verifying that this hidden record is an\n        // own property, not a hidden record from up the prototype chain.\n        //\n        // NOTE: Because this WeakMap emulation is meant only for systems like\n        // SES where Object.prototype is frozen without any numeric\n        // properties, it is ok to use an object literal for the hiddenRecord.\n        // This has two advantages:\n        // * It is much faster in a performance critical place\n        // * It avoids relying on Object.create(null), which had been\n        //   problematic on Chrome 28.0.1480.0. See\n        //   https://code.google.com/p/google-caja/issues/detail?id=1687\n        hiddenRecord = {\n            key: key\n        };\n        // When using this WeakMap emulation on platforms where\n        // Object.prototype might not be frozen and Object.create(null) is\n        // reliable, use the following two commented out lines instead.\n        // hiddenRecord = Object.create(null);\n        // hiddenRecord.key = key;\n        // Please contact us if you need this to work on platforms where\n        // Object.prototype might not be frozen and\n        // Object.create(null) might not be reliable.\n        try {\n            defProp(key, HIDDEN_NAME, {\n                value: hiddenRecord,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n            return hiddenRecord;\n        } catch (error) {\n            // Under some circumstances, isExtensible seems to misreport whether\n            // the HIDDEN_NAME can be defined.\n            // The circumstances have not been isolated, but at least affect\n            // Node.js v0.10.26 on TravisCI / Linux, but not the same version of\n            // Node.js on OS X.\n            return void 0;\n        }\n    }\n    /**\n   * Monkey patch operations that would make their argument\n   * non-extensible.\n   *\n   * <p>The monkey patched versions throw a TypeError if their\n   * argument is not an object, so it should only be done to functions\n   * that should throw a TypeError anyway if their argument is not an\n   * object.\n   */ (function() {\n        var oldFreeze = Object.freeze;\n        defProp(Object, \"freeze\", {\n            value: function identifyingFreeze(obj) {\n                getHiddenRecord(obj);\n                return oldFreeze(obj);\n            }\n        });\n        var oldSeal = Object.seal;\n        defProp(Object, \"seal\", {\n            value: function identifyingSeal(obj) {\n                getHiddenRecord(obj);\n                return oldSeal(obj);\n            }\n        });\n        var oldPreventExtensions = Object.preventExtensions;\n        defProp(Object, \"preventExtensions\", {\n            value: function identifyingPreventExtensions(obj) {\n                getHiddenRecord(obj);\n                return oldPreventExtensions(obj);\n            }\n        });\n    })();\n    function constFunc(func) {\n        func.prototype = null;\n        return Object.freeze(func);\n    }\n    var calledAsFunctionWarningDone = false;\n    function calledAsFunctionWarning() {\n        // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()\n        // but we used to permit it and do it ourselves, so warn only.\n        if (!calledAsFunctionWarningDone && typeof console !== \"undefined\") {\n            calledAsFunctionWarningDone = true;\n            console.warn(\"WeakMap should be invoked as new WeakMap(), not \" + \"WeakMap(). This will be an error in the future.\");\n        }\n    }\n    var nextId = 0;\n    var OurWeakMap = function() {\n        if (!(this instanceof OurWeakMap)) {\n            calledAsFunctionWarning();\n        }\n        // We are currently (12/25/2012) never encountering any prematurely\n        // non-extensible keys.\n        var keys = []; // brute force for prematurely non-extensible keys.\n        var values = []; // brute force for corresponding values.\n        var id = nextId++;\n        function get___(key, opt_default) {\n            var index;\n            var hiddenRecord = getHiddenRecord(key);\n            if (hiddenRecord) {\n                return id in hiddenRecord ? hiddenRecord[id] : opt_default;\n            } else {\n                index = keys.indexOf(key);\n                return index >= 0 ? values[index] : opt_default;\n            }\n        }\n        function has___(key) {\n            var hiddenRecord = getHiddenRecord(key);\n            if (hiddenRecord) {\n                return id in hiddenRecord;\n            } else {\n                return keys.indexOf(key) >= 0;\n            }\n        }\n        function set___(key, value) {\n            var index;\n            var hiddenRecord = getHiddenRecord(key);\n            if (hiddenRecord) {\n                hiddenRecord[id] = value;\n            } else {\n                index = keys.indexOf(key);\n                if (index >= 0) {\n                    values[index] = value;\n                } else {\n                    // Since some browsers preemptively terminate slow turns but\n                    // then continue computing with presumably corrupted heap\n                    // state, we here defensively get keys.length first and then\n                    // use it to update both the values and keys arrays, keeping\n                    // them in sync.\n                    index = keys.length;\n                    values[index] = value;\n                    // If we crash here, values will be one longer than keys.\n                    keys[index] = key;\n                }\n            }\n            return this;\n        }\n        function delete___(key) {\n            var hiddenRecord = getHiddenRecord(key);\n            var index, lastIndex;\n            if (hiddenRecord) {\n                return id in hiddenRecord && delete hiddenRecord[id];\n            } else {\n                index = keys.indexOf(key);\n                if (index < 0) {\n                    return false;\n                }\n                // Since some browsers preemptively terminate slow turns but\n                // then continue computing with potentially corrupted heap\n                // state, we here defensively get keys.length first and then use\n                // it to update both the keys and the values array, keeping\n                // them in sync. We update the two with an order of assignments,\n                // such that any prefix of these assignments will preserve the\n                // key/value correspondence, either before or after the delete.\n                // Note that this needs to work correctly when index === lastIndex.\n                lastIndex = keys.length - 1;\n                keys[index] = void 0;\n                // If we crash here, there's a void 0 in the keys array, but\n                // no operation will cause a \"keys.indexOf(void 0)\", since\n                // getHiddenRecord(void 0) will always throw an error first.\n                values[index] = values[lastIndex];\n                // If we crash here, values[index] cannot be found here,\n                // because keys[index] is void 0.\n                keys[index] = keys[lastIndex];\n                // If index === lastIndex and we crash here, then keys[index]\n                // is still void 0, since the aliasing killed the previous key.\n                keys.length = lastIndex;\n                // If we crash here, keys will be one shorter than values.\n                values.length = lastIndex;\n                return true;\n            }\n        }\n        return Object.create(OurWeakMap.prototype, {\n            get___: {\n                value: constFunc(get___)\n            },\n            has___: {\n                value: constFunc(has___)\n            },\n            set___: {\n                value: constFunc(set___)\n            },\n            delete___: {\n                value: constFunc(delete___)\n            }\n        });\n    };\n    OurWeakMap.prototype = Object.create(Object.prototype, {\n        get: {\n            /**\n       * Return the value most recently associated with key, or\n       * opt_default if none.\n       */ value: function get(key, opt_default) {\n                return this.get___(key, opt_default);\n            },\n            writable: true,\n            configurable: true\n        },\n        has: {\n            /**\n       * Is there a value associated with key in this WeakMap?\n       */ value: function has(key) {\n                return this.has___(key);\n            },\n            writable: true,\n            configurable: true\n        },\n        set: {\n            /**\n       * Associate value with key in this WeakMap, overwriting any\n       * previous association if present.\n       */ value: function set(key, value) {\n                return this.set___(key, value);\n            },\n            writable: true,\n            configurable: true\n        },\n        \"delete\": {\n            /**\n       * Remove any association for key in this WeakMap, returning\n       * whether there was one.\n       *\n       * <p>Note that the boolean return here does not work like the\n       * {@code delete} operator. The {@code delete} operator returns\n       * whether the deletion succeeds at bringing about a state in\n       * which the deleted property is absent. The {@code delete}\n       * operator therefore returns true if the property was already\n       * absent, whereas this {@code delete} method returns false if\n       * the association was already absent.\n       */ value: function remove(key) {\n                return this.delete___(key);\n            },\n            writable: true,\n            configurable: true\n        }\n    });\n    if (typeof HostWeakMap === \"function\") {\n        (function() {\n            // If we got here, then the platform has a WeakMap but we are concerned\n            // that it may refuse to store some key types. Therefore, make a map\n            // implementation which makes use of both as possible.\n            // In this mode we are always using double maps, so we are not proxy-safe.\n            // This combination does not occur in any known browser, but we had best\n            // be safe.\n            if (doubleWeakMapCheckSilentFailure && typeof Proxy !== \"undefined\") {\n                Proxy = undefined;\n            }\n            function DoubleWeakMap() {\n                if (!(this instanceof OurWeakMap)) {\n                    calledAsFunctionWarning();\n                }\n                // Preferable, truly weak map.\n                var hmap = new HostWeakMap();\n                // Our hidden-property-based pseudo-weak-map. Lazily initialized in the\n                // 'set' implementation; thus we can avoid performing extra lookups if\n                // we know all entries actually stored are entered in 'hmap'.\n                var omap = undefined;\n                // Hidden-property maps are not compatible with proxies because proxies\n                // can observe the hidden name and either accidentally expose it or fail\n                // to allow the hidden property to be set. Therefore, we do not allow\n                // arbitrary WeakMaps to switch to using hidden properties, but only\n                // those which need the ability, and unprivileged code is not allowed\n                // to set the flag.\n                //\n                // (Except in doubleWeakMapCheckSilentFailure mode in which case we\n                // disable proxies.)\n                var enableSwitching = false;\n                function dget(key, opt_default) {\n                    if (omap) {\n                        return hmap.has(key) ? hmap.get(key) : omap.get___(key, opt_default);\n                    } else {\n                        return hmap.get(key, opt_default);\n                    }\n                }\n                function dhas(key) {\n                    return hmap.has(key) || (omap ? omap.has___(key) : false);\n                }\n                var dset;\n                if (doubleWeakMapCheckSilentFailure) {\n                    dset = function(key, value) {\n                        hmap.set(key, value);\n                        if (!hmap.has(key)) {\n                            if (!omap) {\n                                omap = new OurWeakMap();\n                            }\n                            omap.set(key, value);\n                        }\n                        return this;\n                    };\n                } else {\n                    dset = function(key, value) {\n                        if (enableSwitching) {\n                            try {\n                                hmap.set(key, value);\n                            } catch (e) {\n                                if (!omap) {\n                                    omap = new OurWeakMap();\n                                }\n                                omap.set___(key, value);\n                            }\n                        } else {\n                            hmap.set(key, value);\n                        }\n                        return this;\n                    };\n                }\n                function ddelete(key) {\n                    var result = !!hmap[\"delete\"](key);\n                    if (omap) {\n                        return omap.delete___(key) || result;\n                    }\n                    return result;\n                }\n                return Object.create(OurWeakMap.prototype, {\n                    get___: {\n                        value: constFunc(dget)\n                    },\n                    has___: {\n                        value: constFunc(dhas)\n                    },\n                    set___: {\n                        value: constFunc(dset)\n                    },\n                    delete___: {\n                        value: constFunc(ddelete)\n                    },\n                    permitHostObjects___: {\n                        value: constFunc(function(token) {\n                            if (token === weakMapPermitHostObjects) {\n                                enableSwitching = true;\n                            } else {\n                                throw new Error(\"bogus call to permitHostObjects___\");\n                            }\n                        })\n                    }\n                });\n            }\n            DoubleWeakMap.prototype = OurWeakMap.prototype;\n            module.exports = DoubleWeakMap;\n            // define .constructor to hide OurWeakMap ctor\n            Object.defineProperty(WeakMap.prototype, \"constructor\", {\n                value: WeakMap,\n                enumerable: false,\n                configurable: true,\n                writable: true\n            });\n        })();\n    } else {\n        // There is no host WeakMap, so we must use the emulation.\n        // Emulated WeakMaps are incompatible with native proxies (because proxies\n        // can observe the hidden name), so we must disable Proxy usage (in\n        // ArrayLike and Domado, currently).\n        if (typeof Proxy !== \"undefined\") {\n            Proxy = undefined;\n        }\n        module.exports = OurWeakMap;\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYWstbWFwL3dlYWstbWFwLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxpQ0FBaUM7QUFDakMsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFFakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUVEOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0EsVUFBU0E7SUFDUjtJQUVBLElBQUksT0FBT0MsUUFBUSxlQUFlQSxJQUFJQyxFQUFFLElBQUksQ0FBQ0QsSUFBSUMsRUFBRSxJQUFJO1FBQ3JELGlDQUFpQztRQUNqQztJQUNGO0lBRUE7Ozs7Ozs7Ozs7OztHQVlDLEdBQ0QsU0FBU0MseUJBQXlCQyxHQUFHO1FBQ25DLGlFQUFpRTtRQUNqRSxJQUFJQSxJQUFJQyxvQkFBb0IsRUFBRTtZQUM1QkQsSUFBSUMsb0JBQW9CLENBQUNGO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJLE9BQU9GLFFBQVEsYUFBYTtRQUM5QkEsSUFBSUUsd0JBQXdCLEdBQUdBO0lBQ2pDO0lBRUEseUVBQXlFO0lBQ3pFLDREQUE0RDtJQUM1RCxJQUFJRyxrQ0FBa0M7SUFFdEMsNEVBQTRFO0lBQzVFLDZCQUE2QjtJQUM3QixJQUFJLE9BQU9DLFlBQVksWUFBWTtRQUNqQyxJQUFJQyxjQUFjRDtRQUNsQiwyQ0FBMkM7UUFDM0MsSUFBSSxPQUFPRSxjQUFjLGVBQ3JCLFVBQVVDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUyxHQUFHO1FBQ3ZDLG9FQUFvRTtRQUNwRSx5RUFBeUU7UUFDekUscUVBQXFFO1FBQ3JFLHdFQUF3RTtRQUV4RSx1RUFBdUU7UUFDdkUsU0FB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QUNGO29CQUFFO2dCQUNKO1lBQ0Y7WUFDQVgsY0FBY3pFLFNBQVMsR0FBR3dELFdBQVd4RCxTQUFTO1lBQzlDSCxPQUFPQyxPQUFPLEdBQUcyRTtZQUVqQiw4Q0FBOEM7WUFDOUNoRixPQUFPWSxjQUFjLENBQUNuQixRQUFRYyxTQUFTLEVBQUUsZUFBZTtnQkFDdEQwQixPQUFPeEM7Z0JBQ1BvRCxZQUFZO2dCQUNaQyxjQUFjO2dCQUNkRixVQUFVO1lBQ1o7UUFDRjtJQUNGLE9BQU87UUFDTCwwREFBMEQ7UUFFMUQsMEVBQTBFO1FBQzFFLG1FQUFtRTtRQUNuRSxvQ0FBb0M7UUFDcEMsSUFBSSxPQUFPa0MsVUFBVSxhQUFhO1lBQ2hDQSxRQUFRQztRQUNWO1FBRUEzRSxPQUFPQyxPQUFPLEdBQUcwRDtJQUNuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHZpc2l0b3JpcS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYWstbWFwL3dlYWstbWFwLmpzPzAxYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJbnN0YWxsIGEgbGVha3kgV2Vha01hcCBlbXVsYXRpb24gb24gcGxhdGZvcm1zIHRoYXRcbiAqIGRvbid0IHByb3ZpZGUgYSBidWlsdC1pbiBvbmUuXG4gKlxuICogPHA+QXNzdW1lcyB0aGF0IGFuIEVTNSBwbGF0Zm9ybSB3aGVyZSwgaWYge0Bjb2RlIFdlYWtNYXB9IGlzXG4gKiBhbHJlYWR5IHByZXNlbnQsIHRoZW4gaXQgY29uZm9ybXMgdG8gdGhlIGFudGljaXBhdGVkIEVTNlxuICogc3BlY2lmaWNhdGlvbi4gVG8gcnVuIHRoaXMgZmlsZSBvbiBhbiBFUzUgb3IgYWxtb3N0IEVTNVxuICogaW1wbGVtZW50YXRpb24gd2hlcmUgdGhlIHtAY29kZSBXZWFrTWFwfSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90XG4gKiBxdWl0ZSBjb25mb3JtLCBydW4gPGNvZGU+cmVwYWlyRVM1LmpzPC9jb2RlPiBmaXJzdC5cbiAqXG4gKiA8cD5FdmVuIHRob3VnaCBXZWFrTWFwTW9kdWxlIGlzIG5vdCBnbG9iYWwsIHRoZSBsaW50ZXIgdGhpbmtzIGl0XG4gKiBpcywgd2hpY2ggaXMgd2h5IGl0IGlzIGluIHRoZSBvdmVycmlkZXMgbGlzdCBiZWxvdy5cbiAqXG4gKiA8cD5OT1RFOiBCZWZvcmUgdXNpbmcgdGhpcyBXZWFrTWFwIGVtdWxhdGlvbiBpbiBhIG5vbi1TRVNcbiAqIGVudmlyb25tZW50LCBzZWUgdGhlIG5vdGUgYmVsb3cgYWJvdXQgaGlkZGVuUmVjb3JkLlxuICpcbiAqIEBhdXRob3IgTWFyayBTLiBNaWxsZXJcbiAqIEByZXF1aXJlcyBjcnlwdG8sIEFycmF5QnVmZmVyLCBVaW50OEFycmF5LCBuYXZpZ2F0b3IsIGNvbnNvbGVcbiAqIEBvdmVycmlkZXMgV2Vha01hcCwgc2VzLCBQcm94eVxuICogQG92ZXJyaWRlcyBXZWFrTWFwTW9kdWxlXG4gKi9cblxuLyoqXG4gKiBUaGlzIHtAY29kZSBXZWFrTWFwfSBlbXVsYXRpb24gaXMgb2JzZXJ2YWJseSBlcXVpdmFsZW50IHRvIHRoZVxuICogRVMtSGFybW9ueSBXZWFrTWFwLCBidXQgd2l0aCBsZWFraWVyIGdhcmJhZ2UgY29sbGVjdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIDxwPkFzIHdpdGggdHJ1ZSBXZWFrTWFwcywgaW4gdGhpcyBlbXVsYXRpb24sIGEga2V5IGRvZXMgbm90XG4gKiByZXRhaW4gbWFwcyBpbmRleGVkIGJ5IHRoYXQga2V5IGFuZCAoY3J1Y2lhbGx5KSBhIG1hcCBkb2VzIG5vdFxuICogcmV0YWluIHRoZSBrZXlzIGl0IGluZGV4ZXMuIEEgbWFwIGJ5IGl0c2VsZiBhbHNvIGRvZXMgbm90IHJldGFpblxuICogdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhhdCBtYXAuXG4gKlxuICogPHA+SG93ZXZlciwgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggYSBrZXkgaW4gc29tZSBtYXAgYXJlXG4gKiByZXRhaW5lZCBzbyBsb25nIGFzIHRoYXQga2V5IGlzIHJldGFpbmVkIGFuZCB0aG9zZSBhc3NvY2lhdGlvbnMgYXJlXG4gKiBub3Qgb3ZlcnJpZGRlbi4gRm9yIGV4YW1wbGUsIHdoZW4gdXNlZCB0byBzdXBwb3J0IG1lbWJyYW5lcywgYWxsXG4gKiB2YWx1ZXMgZXhwb3J0ZWQgZnJvbSBhIGdpdmVuIG1lbWJyYW5lIHdpbGwgbGl2ZSBmb3IgdGhlIGxpZmV0aW1lXG4gKiB0aGV5IHdvdWxkIGhhdmUgaGFkIGluIHRoZSBhYnNlbmNlIG9mIGFuIGludGVycG9zZWQgbWVtYnJhbmUuIEV2ZW5cbiAqIHdoZW4gdGhlIG1lbWJyYW5lIGlzIHJldm9rZWQsIGFsbCBvYmplY3RzIHRoYXQgd291bGQgaGF2ZSBiZWVuXG4gKiByZWFjaGFibGUgaW4gdGhlIGFic2VuY2Ugb2YgcmV2b2NhdGlvbiB3aWxsIHN0aWxsIGJlIHJlYWNoYWJsZSwgYXNcbiAqIGZhciBhcyB0aGUgR0MgY2FuIHRlbGwsIGV2ZW4gdGhvdWdoIHRoZXkgd2lsbCBubyBsb25nZXIgYmUgcmVsZXZhbnRcbiAqIHRvIG9uZ29pbmcgY29tcHV0YXRpb24uXG4gKlxuICogPHA+VGhlIEFQSSBpbXBsZW1lbnRlZCBoZXJlIGlzIGFwcHJveGltYXRlbHkgdGhlIEFQSSBhcyBpbXBsZW1lbnRlZFxuICogaW4gRkY2LjBhMSBhbmQgYWdyZWVkIHRvIGJ5IE1hcmtNLCBBbmRyZWFzIEdhbCwgYW5kIERhdmUgSGVybWFuLFxuICogcmF0aGVyIHRoYW4gdGhlIG9mZmlhbGx5IGFwcHJvdmVkIHByb3Bvc2FsIHBhZ2UuIFRPRE8oZXJpZ2h0cyk6XG4gKiB1cGdyYWRlIHRoZSBlY21hc2NyaXB0IFdlYWtNYXAgcHJvcG9zYWwgcGFnZSB0byBleHBsYWluIHRoaXMgQVBJXG4gKiBjaGFuZ2UgYW5kIHByZXNlbnQgdG8gRWNtYVNjcmlwdCBjb21taXR0ZWUgZm9yIHRoZWlyIGFwcHJvdmFsLlxuICpcbiAqIDxwPlRoZSBmaXJzdCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGVtdWxhdGlvbiBoZXJlIGFuZCB0aGF0IGluXG4gKiBGRjYuMGExIGlzIHRoZSBwcmVzZW5jZSBvZiBub24gZW51bWVyYWJsZSB7QGNvZGUgZ2V0X19fLCBoYXNfX18sXG4gKiBzZXRfX18sIGFuZCBkZWxldGVfX199IG1ldGhvZHMgb24gV2Vha01hcCBpbnN0YW5jZXMgdG8gcmVwcmVzZW50XG4gKiB3aGF0IHdvdWxkIGJlIHRoZSBoaWRkZW4gaW50ZXJuYWwgcHJvcGVydGllcyBvZiBhIHByaW1pdGl2ZVxuICogaW1wbGVtZW50YXRpb24uIFdoZXJlYXMgdGhlIEZGNi4wYTEgV2Vha01hcC5wcm90b3R5cGUgbWV0aG9kc1xuICogcmVxdWlyZSB0aGVpciB7QGNvZGUgdGhpc30gdG8gYmUgYSBnZW51aW5lIFdlYWtNYXAgaW5zdGFuY2UgKGkuZS4sXG4gKiBhbiBvYmplY3Qgb2Yge0Bjb2RlIFtbQ2xhc3NdXX0gXCJXZWFrTWFwfSksIHNpbmNlIHRoZXJlIGlzIG5vdGhpbmdcbiAqIHVuZm9yZ2VhYmxlIGFib3V0IHRoZSBwc2V1ZG8taW50ZXJuYWwgbWV0aG9kIG5hbWVzIHVzZWQgaGVyZSxcbiAqIG5vdGhpbmcgcHJldmVudHMgdGhlc2UgZW11bGF0ZWQgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBiZWluZ1xuICogYXBwbGllZCB0byBub24tV2Vha01hcHMgd2l0aCBwc2V1ZG8taW50ZXJuYWwgbWV0aG9kcyBvZiB0aGUgc2FtZVxuICogbmFtZXMuXG4gKlxuICogPHA+QW5vdGhlciBkaWZmZXJlbmNlIGlzIHRoYXQgb3VyIGVtdWxhdGVkIHtAY29kZVxuICogV2Vha01hcC5wcm90b3R5cGV9IGlzIG5vdCBpdHNlbGYgYSBXZWFrTWFwLiBBIHByb2JsZW0gd2l0aCB0aGVcbiAqIGN1cnJlbnQgRkY2LjBhMSBBUEkgaXMgdGhhdCBXZWFrTWFwLnByb3RvdHlwZSBpcyBpdHNlbGYgYSBXZWFrTWFwXG4gKiBwcm92aWRpbmcgYW1iaWVudCBtdXRhYmlsaXR5IGFuZCBhbiBhbWJpZW50IGNvbW11bmljYXRpb25zXG4gKiBjaGFubmVsLiBUaHVzLCBpZiBhIFdlYWtNYXAgaXMgYWxyZWFkeSBwcmVzZW50IGFuZCBoYXMgdGhpc1xuICogcHJvYmxlbSwgcmVwYWlyRVM1LmpzIHdyYXBzIGl0IGluIGEgc2FmZSB3cmFwcHBlciBpbiBvcmRlciB0b1xuICogcHJldmVudCBhY2Nlc3MgdG8gdGhpcyBjaGFubmVsLiAoU2VlXG4gKiBQQVRDSF9NVVRBQkxFX0ZST1pFTl9XRUFLTUFQX1BST1RPIGluIHJlcGFpckVTNS5qcykuXG4gKi9cblxuLyoqXG4gKiBJZiB0aGlzIGlzIGEgZnVsbCA8YSBocmVmPVxuICogXCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZXMtbGFiL3dpa2kvU2VjdXJlYWJsZUVTNVwiXG4gKiA+c2VjdXJlYWJsZSBFUzU8L2E+IHBsYXRmb3JtIGFuZCB0aGUgRVMtSGFybW9ueSB7QGNvZGUgV2Vha01hcH0gaXNcbiAqIGFic2VudCwgaW5zdGFsbCBhbiBhcHByb3hpbWF0ZSBlbXVsYXRpb24uXG4gKlxuICogPHA+SWYgV2Vha01hcCBpcyBwcmVzZW50IGJ1dCBjYW5ub3Qgc3RvcmUgc29tZSBvYmplY3RzLCB1c2Ugb3VyIGFwcHJveGltYXRlXG4gKiBlbXVsYXRpb24gYXMgYSB3cmFwcGVyLlxuICpcbiAqIDxwPklmIHRoaXMgaXMgYWxtb3N0IGEgc2VjdXJlYWJsZSBFUzUgcGxhdGZvcm0sIHRoZW4gV2Vha01hcC5qc1xuICogc2hvdWxkIGJlIHJ1biBhZnRlciByZXBhaXJFUzUuanMuXG4gKlxuICogPHA+U2VlIHtAY29kZSBXZWFrTWFwfSBmb3IgZG9jdW1lbnRhdGlvbiBvZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gKiBwcm9wZXJ0aWVzIG9mIHRoaXMgV2Vha01hcCBlbXVsYXRpb24uXG4gKi9cbihmdW5jdGlvbiBXZWFrTWFwTW9kdWxlKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAodHlwZW9mIHNlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VzLm9rICYmICFzZXMub2soKSkge1xuICAgIC8vIGFscmVhZHkgdG9vIGJyb2tlbiwgc28gZ2l2ZSB1cFxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBzb21lIGNhc2VzIChjdXJyZW50IEZpcmVmb3gpLCB3ZSBtdXN0IG1ha2UgYSBjaG9pY2UgYmV0d2VlZW4gYVxuICAgKiBXZWFrTWFwIHdoaWNoIGlzIGNhcGFibGUgb2YgdXNpbmcgYWxsIHZhcmlldGllcyBvZiBob3N0IG9iamVjdHMgYXNcbiAgICoga2V5cyBhbmQgb25lIHdoaWNoIGlzIGNhcGFibGUgb2Ygc2FmZWx5IHVzaW5nIHByb3hpZXMgYXMga2V5cy4gU2VlXG4gICAqIGNvbW1lbnRzIGJlbG93IGFib3V0IEhvc3RXZWFrTWFwIGFuZCBEb3VibGVXZWFrTWFwIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uICh3aGljaCBpcyBhIGdsb2JhbCwgbm90IGV4cG9zZWQgdG8gZ3Vlc3RzKSBtYXJrcyBhXG4gICAqIFdlYWtNYXAgYXMgcGVybWl0dGVkIHRvIGRvIHdoYXQgaXMgbmVjZXNzYXJ5IHRvIGluZGV4IGFsbCBob3N0XG4gICAqIG9iamVjdHMsIGF0IHRoZSBjb3N0IG9mIG1ha2luZyBpdCB1bnNhZmUgZm9yIHByb3hpZXMuXG4gICAqXG4gICAqIERvIG5vdCBhcHBseSB0aGlzIGZ1bmN0aW9uIHRvIGFueXRoaW5nIHdoaWNoIGlzIG5vdCBhIGdlbnVpbmVcbiAgICogZnJlc2ggV2Vha01hcC5cbiAgICovXG4gIGZ1bmN0aW9uIHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cyhtYXApIHtcbiAgICAvLyBpZGVudGl0eSBvZiBmdW5jdGlvbiB1c2VkIGFzIGEgc2VjcmV0IC0tIGdvb2QgZW5vdWdoIGFuZCBjaGVhcFxuICAgIGlmIChtYXAucGVybWl0SG9zdE9iamVjdHNfX18pIHtcbiAgICAgIG1hcC5wZXJtaXRIb3N0T2JqZWN0c19fXyh3ZWFrTWFwUGVybWl0SG9zdE9iamVjdHMpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzZXMud2Vha01hcFBlcm1pdEhvc3RPYmplY3RzID0gd2Vha01hcFBlcm1pdEhvc3RPYmplY3RzO1xuICB9XG5cbiAgLy8gSUUgMTEgaGFzIG5vIFByb3h5IGJ1dCBoYXMgYSBicm9rZW4gV2Vha01hcCBzdWNoIHRoYXQgd2UgbmVlZCB0byBwYXRjaFxuICAvLyBpdCB1c2luZyBEb3VibGVXZWFrTWFwOyB0aGlzIGZsYWcgdGVsbHMgRG91YmxlV2Vha01hcCBzby5cbiAgdmFyIGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgPSBmYWxzZTtcblxuICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ29vZC1lbm91Z2ggV2Vha01hcCBpbXBsZW1lbnRhdGlvbiwgYW5kIGlmIHNvXG4gIC8vIGV4aXQgd2l0aG91dCByZXBsYWNpbmcgaXQuXG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBIb3N0V2Vha01hcCA9IFdlYWtNYXA7XG4gICAgLy8gVGhlcmUgaXMgYSBXZWFrTWFwIC0tIGlzIGl0IGdvb2QgZW5vdWdoP1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvRmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgLy8gV2UncmUgbm93ICphc3N1bWluZyBub3QqLCBiZWNhdXNlIGFzIG9mIHRoaXMgd3JpdGluZyAoMjAxMy0wNS0wNilcbiAgICAgIC8vIEZpcmVmb3gncyBXZWFrTWFwcyBoYXZlIGEgbWlzY2VsbGFueSBvZiBvYmplY3RzIHRoZXkgd29uJ3QgYWNjZXB0LCBhbmRcbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gbWFrZSBhbiBleGhhdXN0aXZlIGxpc3QsIGFuZCB0ZXN0aW5nIGZvciBqdXN0IG9uZVxuICAgICAgLy8gd2lsbCBiZSBhIHByb2JsZW0gaWYgdGhhdCBvbmUgaXMgZml4ZWQgYWxvbmUgKGFzIHRoZXkgZGlkIGZvciBFdmVudCkuXG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGxhdGZvcm0gdGhhdCB3ZSAqY2FuKiByZWxpYWJseSB0ZXN0IG9uLCBoZXJlJ3MgaG93IHRvXG4gICAgICAvLyBkbyBpdDpcbiAgICAgIC8vICB2YXIgcHJvYmxlbWF0aWMgPSAuLi4gO1xuICAgICAgLy8gIHZhciB0ZXN0SG9zdE1hcCA9IG5ldyBIb3N0V2Vha01hcCgpO1xuICAgICAgLy8gIHRyeSB7XG4gICAgICAvLyAgICB0ZXN0SG9zdE1hcC5zZXQocHJvYmxlbWF0aWMsIDEpOyAgLy8gRmlyZWZveCAyMCB3aWxsIHRocm93IGhlcmVcbiAgICAgIC8vICAgIGlmICh0ZXN0SG9zdE1hcC5nZXQocHJvYmxlbWF0aWMpID09PSAxKSB7XG4gICAgICAvLyAgICAgIHJldHVybjtcbiAgICAgIC8vICAgIH1cbiAgICAgIC8vICB9IGNhdGNoIChlKSB7fVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIDExIGJ1ZzogV2Vha01hcHMgc2lsZW50bHkgZmFpbCB0byBzdG9yZSBmcm96ZW4gb2JqZWN0cy5cbiAgICAgIHZhciB0ZXN0TWFwID0gbmV3IEhvc3RXZWFrTWFwKCk7XG4gICAgICB2YXIgdGVzdE9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgICAgdGVzdE1hcC5zZXQodGVzdE9iamVjdCwgMSk7XG4gICAgICBpZiAodGVzdE1hcC5nZXQodGVzdE9iamVjdCkgIT09IDEpIHtcbiAgICAgICAgZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBpbnN0YWxsaW5nIG91ciBXZWFrTWFwLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBnb3BuID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBkZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuICAvKipcbiAgICogU2VjdXJpdHkgZGVwZW5kcyBvbiBISURERU5fTkFNRSBiZWluZyBib3RoIDxpPnVuZ3Vlc3NhYmxlPC9pPiBhbmRcbiAgICogPGk+dW5kaXNjb3ZlcmFibGU8L2k+IGJ5IHVudHJ1c3RlZCBjb2RlLlxuICAgKlxuICAgKiA8cD5HaXZlbiB0aGUga25vd24gd2Vha25lc3NlcyBvZiBNYXRoLnJhbmRvbSgpIG9uIGV4aXN0aW5nXG4gICAqIGJyb3dzZXJzLCBpdCBkb2VzIG5vdCBnZW5lcmF0ZSB1bmd1ZXNzYWJpbGl0eSB3ZSBjYW4gYmUgY29uZmlkZW50XG4gICAqIG9mLlxuICAgKlxuICAgKiA8cD5JdCBpcyB0aGUgbW9ua2V5IHBhdGNoaW5nIGxvZ2ljIGluIHRoaXMgZmlsZSB0aGF0IGlzIGludGVuZGVkXG4gICAqIHRvIGVuc3VyZSB1bmRpc2NvdmVyYWJpbGl0eS4gVGhlIGJhc2ljIGlkZWEgaXMgdGhhdCB0aGVyZSBhcmVcbiAgICogdGhyZWUgZnVuZGFtZW50YWwgbWVhbnMgb2YgZGlzY292ZXJpbmcgcHJvcGVydGllcyBvZiBhbiBvYmplY3Q6XG4gICAqIFRoZSBmb3IvaW4gbG9vcCwgT2JqZWN0LmtleXMoKSwgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCksXG4gICAqIGFzIHdlbGwgYXMgc29tZSBwcm9wb3NlZCBFUzYgZXh0ZW5zaW9ucyB0aGF0IGFwcGVhciBvbiBvdXJcbiAgICogd2hpdGVsaXN0LiBUaGUgZmlyc3QgdHdvIG9ubHkgZGlzY292ZXIgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCBhbmRcbiAgICogd2Ugb25seSB1c2UgSElEREVOX05BTUUgdG8gbmFtZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LCBzbyB0aGVcbiAgICogb25seSByZW1haW5pbmcgdGhyZWF0IHNob3VsZCBiZSBnZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBzb21lXG4gICAqIHByb3Bvc2VkIEVTNiBleHRlbnNpb25zIHRoYXQgYXBwZWFyIG9uIG91ciB3aGl0ZWxpc3QuIFdlIG1vbmtleVxuICAgKiBwYXRjaCB0aGVtIHRvIHJlbW92ZSBISURERU5fTkFNRSBmcm9tIHRoZSBsaXN0IG9mIHByb3BlcnRpZXMgdGhleVxuICAgKiByZXR1cm5zLlxuICAgKlxuICAgKiA8cD5UT0RPKGVyaWdodHMpOiBPbiBhIHBsYXRmb3JtIHdpdGggYnVpbHQtaW4gUHJveGllcywgcHJveGllc1xuICAgKiBjb3VsZCBiZSB1c2VkIHRvIHRyYXAgYW5kIHRoZXJlYnkgZGlzY292ZXIgdGhlIEhJRERFTl9OQU1FLCBzbyB3ZVxuICAgKiBuZWVkIHRvIG1vbmtleSBwYXRjaCBQcm94eS5jcmVhdGUsIFByb3h5LmNyZWF0ZUZ1bmN0aW9uLCBldGMsIGluXG4gICAqIG9yZGVyIHRvIHdyYXAgdGhlIHByb3ZpZGVkIGhhbmRsZXIgd2l0aCB0aGUgcmVhbCBoYW5kbGVyIHdoaWNoXG4gICAqIGZpbHRlcnMgb3V0IGFsbCB0cmFwcyB1c2luZyBISURERU5fTkFNRS5cbiAgICpcbiAgICogPHA+VE9ETyhlcmlnaHRzKTogUmV2aXNpdCBNaWtlIFN0YXkncyBzdWdnZXN0aW9uIHRoYXQgd2UgdXNlIGFuXG4gICAqIGVuY2Fwc3VsYXRlZCBmdW5jdGlvbiBhdCBhIG5vdC1uZWNlc3NhcmlseS1zZWNyZXQgbmFtZSwgd2hpY2hcbiAgICogdXNlcyB0aGUgU3RpZWdsZXIgc2hhcmVkLXN0YXRlIHJpZ2h0cyBhbXBsaWZpY2F0aW9uIHBhdHRlcm4gdG9cbiAgICogcmV2ZWFsIHRoZSBhc3NvY2lhdGVkIHZhbHVlIG9ubHkgdG8gdGhlIFdlYWtNYXAgaW4gd2hpY2ggdGhpcyBrZXlcbiAgICogaXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgdmFsdWUuIFNpbmNlIG9ubHkgdGhlIGtleSByZXRhaW5zIHRoZVxuICAgKiBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGNhbiBhbHNvIHJlbWVtYmVyIHRoZSBrZXkgd2l0aG91dCBjYXVzaW5nXG4gICAqIGxlYWthZ2Ugb2YgdGhlIGtleSwgc28gdGhpcyBkb2Vzbid0IHZpb2xhdGUgb3VyIGdlbmVyYWwgZ2NcbiAgICogZ29hbHMuIEluIGFkZGl0aW9uLCBiZWNhdXNlIHRoZSBuYW1lIG5lZWQgbm90IGJlIGEgZ3VhcmRlZFxuICAgKiBzZWNyZXQsIHdlIGNvdWxkIGVmZmljaWVudGx5IGhhbmRsZSBjcm9zcy1mcmFtZSBmcm96ZW4ga2V5cy5cbiAgICovXG4gIHZhciBISURERU5fTkFNRV9QUkVGSVggPSAnd2Vha21hcDonO1xuICB2YXIgSElEREVOX05BTUUgPSBISURERU5fTkFNRV9QUkVGSVggKyAnaWRlbnQ6JyArIE1hdGgucmFuZG9tKCkgKyAnX19fJztcblxuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKDI1KTtcbiAgICB2YXIgdThzID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModThzKTtcbiAgICBISURERU5fTkFNRSA9IEhJRERFTl9OQU1FX1BSRUZJWCArICdyYW5kOicgK1xuICAgICAgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHU4cywgZnVuY3Rpb24odTgpIHtcbiAgICAgICAgcmV0dXJuICh1OCAlIDM2KS50b1N0cmluZygzNik7XG4gICAgICB9KS5qb2luKCcnKSArICdfX18nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RIaWRkZW5OYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gIShcbiAgICAgICAgbmFtZS5zdWJzdHIoMCwgSElEREVOX05BTUVfUFJFRklYLmxlbmd0aCkgPT0gSElEREVOX05BTUVfUFJFRklYICYmXG4gICAgICAgIG5hbWUuc3Vic3RyKG5hbWUubGVuZ3RoIC0gMykgPT09ICdfX18nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25rZXkgcGF0Y2ggZ2V0T3duUHJvcGVydHlOYW1lcyB0byBhdm9pZCByZXZlYWxpbmcgdGhlXG4gICAqIEhJRERFTl9OQU1FLlxuICAgKlxuICAgKiA8cD5UaGUgRVM1LjEgc3BlYyByZXF1aXJlcyBlYWNoIG5hbWUgdG8gYXBwZWFyIG9ubHkgb25jZSwgYnV0IGFzXG4gICAqIG9mIHRoaXMgd3JpdGluZywgdGhpcyByZXF1aXJlbWVudCBpcyBjb250cm92ZXJzaWFsIGZvciBFUzYsIHNvIHdlXG4gICAqIG1hZGUgdGhpcyBjb2RlIHJvYnVzdCBhZ2FpbnN0IHRoaXMgY2FzZS4gSWYgdGhlIHJlc3VsdGluZyBleHRyYVxuICAgKiBzZWFyY2ggdHVybnMgb3V0IHRvIGJlIGV4cGVuc2l2ZSwgd2UgY2FuIHByb2JhYmx5IHJlbGF4IHRoaXMgb25jZVxuICAgKiBFUzYgaXMgYWRlcXVhdGVseSBzdXBwb3J0ZWQgb24gYWxsIG1ham9yIGJyb3dzZXJzLCBpZmYgbm8gYnJvd3NlclxuICAgKiB2ZXJzaW9ucyB3ZSBzdXBwb3J0IGF0IHRoYXQgdGltZSBoYXZlIHJlbGF4ZWQgdGhpcyBjb25zdHJhaW50XG4gICAqIHdpdGhvdXQgcHJvdmlkaW5nIGJ1aWx0LWluIEVTNiBXZWFrTWFwcy5cbiAgICovXG4gIGRlZlByb3AoT2JqZWN0LCAnZ2V0T3duUHJvcGVydHlOYW1lcycsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZUdldE93blByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgICByZXR1cm4gZ29wbihvYmopLmZpbHRlcihpc05vdEhpZGRlbk5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGdldFByb3BlcnR5TmFtZXMgaXMgbm90IGluIEVTNSBidXQgaXQgaXMgcHJvcG9zZWQgZm9yIEVTNiBhbmRcbiAgICogZG9lcyBhcHBlYXIgaW4gb3VyIHdoaXRlbGlzdCwgc28gd2UgbmVlZCB0byBjbGVhbiBpdCB0b28uXG4gICAqL1xuICBpZiAoJ2dldFByb3BlcnR5TmFtZXMnIGluIE9iamVjdCkge1xuICAgIHZhciBvcmlnaW5hbEdldFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0UHJvcGVydHlOYW1lcztcbiAgICBkZWZQcm9wKE9iamVjdCwgJ2dldFByb3BlcnR5TmFtZXMnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZUdldFByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEdldFByb3BlcnR5TmFtZXMob2JqKS5maWx0ZXIoaXNOb3RIaWRkZW5OYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiA8cD5UbyB0cmVhdCBvYmplY3RzIGFzIGlkZW50aXR5LWtleXMgd2l0aCByZWFzb25hYmxlIGVmZmljaWVuY3lcbiAgICogb24gRVM1IGJ5IGl0c2VsZiAoaS5lLiwgd2l0aG91dCBhbnkgb2JqZWN0LWtleWVkIGNvbGxlY3Rpb25zKSwgd2VcbiAgICogbmVlZCB0byBhZGQgYSBoaWRkZW4gcHJvcGVydHkgdG8gc3VjaCBrZXkgb2JqZWN0cyB3aGVuIHdlXG4gICAqIGNhbi4gVGhpcyByYWlzZXMgc2V2ZXJhbCBpc3N1ZXM6XG4gICAqIDx1bD5cbiAgICogPGxpPkFycmFuZ2luZyB0byBhZGQgdGhpcyBwcm9wZXJ0eSB0byBvYmplY3RzIGJlZm9yZSB3ZSBsb3NlIHRoZVxuICAgKiAgICAgY2hhbmNlLCBhbmRcbiAgICogPGxpPkhpZGluZyB0aGUgZXhpc3RlbmNlIG9mIHRoaXMgbmV3IHByb3BlcnR5IGZyb20gbW9zdFxuICAgKiAgICAgSmF2YVNjcmlwdCBjb2RlLlxuICAgKiA8bGk+UHJldmVudGluZyA8aT5jZXJ0aWZpY2F0aW9uIHRoZWZ0PC9pPiwgd2hlcmUgb25lIG9iamVjdCBpc1xuICAgKiAgICAgY3JlYXRlZCBmYWxzZWx5IGNsYWltaW5nIHRvIGJlIHRoZSBrZXkgb2YgYW4gYXNzb2NpYXRpb25cbiAgICogICAgIGFjdHVhbGx5IGtleWVkIGJ5IGFub3RoZXIgb2JqZWN0LlxuICAgKiA8bGk+UHJldmVudGluZyA8aT52YWx1ZSB0aGVmdDwvaT4sIHdoZXJlIHVudHJ1c3RlZCBjb2RlIHdpdGhcbiAgICogICAgIGFjY2VzcyB0byBhIGtleSBvYmplY3QgYnV0IG5vdCBhIHdlYWsgbWFwIG5ldmVydGhlbGVzc1xuICAgKiAgICAgb2J0YWlucyBhY2Nlc3MgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleSBpbiB0aGF0XG4gICAqICAgICB3ZWFrIG1hcC5cbiAgICogPC91bD5cbiAgICogV2UgZG8gc28gYnlcbiAgICogPHVsPlxuICAgKiA8bGk+TWFraW5nIHRoZSBuYW1lIG9mIHRoZSBoaWRkZW4gcHJvcGVydHkgdW5ndWVzc2FibGUsIHNvIFwiW11cIlxuICAgKiAgICAgaW5kZXhpbmcsIHdoaWNoIHdlIGNhbm5vdCBpbnRlcmNlcHQsIGNhbm5vdCBiZSB1c2VkIHRvIGFjY2Vzc1xuICAgKiAgICAgYSBwcm9wZXJ0eSB3aXRob3V0IGtub3dpbmcgdGhlIG5hbWUuXG4gICAqIDxsaT5NYWtpbmcgdGhlIGhpZGRlbiBwcm9wZXJ0eSBub24tZW51bWVyYWJsZSwgc28gd2UgbmVlZCBub3RcbiAgICogICAgIHdvcnJ5IGFib3V0IGZvci1pbiBsb29wcyBvciB7QGNvZGUgT2JqZWN0LmtleXN9LFxuICAgKiA8bGk+bW9ua2V5IHBhdGNoaW5nIHRob3NlIHJlZmxlY3RpdmUgbWV0aG9kcyB0aGF0IHdvdWxkXG4gICAqICAgICBwcmV2ZW50IGV4dGVuc2lvbnMsIHRvIGFkZCB0aGlzIGhpZGRlbiBwcm9wZXJ0eSBmaXJzdCxcbiAgICogPGxpPm1vbmtleSBwYXRjaGluZyB0aG9zZSBtZXRob2RzIHRoYXQgd291bGQgcmV2ZWFsIHRoaXNcbiAgICogICAgIGhpZGRlbiBwcm9wZXJ0eS5cbiAgICogPC91bD5cbiAgICogVW5mb3J0dW5hdGVseSwgYmVjYXVzZSBvZiBzYW1lLW9yaWdpbiBpZnJhbWVzLCB3ZSBjYW5ub3QgcmVsaWFibHlcbiAgICogYWRkIHRoaXMgaGlkZGVuIHByb3BlcnR5IGJlZm9yZSBhbiBvYmplY3QgYmVjb21lc1xuICAgKiBub24tZXh0ZW5zaWJsZS4gSW5zdGVhZCwgaWYgd2UgZW5jb3VudGVyIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0XG4gICAqIHdpdGhvdXQgYSBoaWRkZW4gcmVjb3JkIHRoYXQgd2UgY2FuIGRldGVjdCAod2hldGhlciBvciBub3QgaXQgaGFzXG4gICAqIGEgaGlkZGVuIHJlY29yZCBzdG9yZWQgdW5kZXIgYSBuYW1lIHNlY3JldCB0byB1cyksIHRoZW4gd2UganVzdFxuICAgKiB1c2UgdGhlIGtleSBvYmplY3QgaXRzZWxmIHRvIHJlcHJlc2VudCBpdHMgaWRlbnRpdHkgaW4gYSBicnV0ZVxuICAgKiBmb3JjZSBsZWFreSBtYXAgc3RvcmVkIGluIHRoZSB3ZWFrIG1hcCwgbG9zaW5nIGFsbCB0aGUgYWR2YW50YWdlc1xuICAgKiBvZiB3ZWFrbmVzcyBmb3IgdGhlc2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRIaWRkZW5SZWNvcmQoa2V5KSB7XG4gICAgaWYgKGtleSAhPT0gT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhbiBvYmplY3Q6ICcgKyBrZXkpO1xuICAgIH1cbiAgICB2YXIgaGlkZGVuUmVjb3JkID0ga2V5W0hJRERFTl9OQU1FXTtcbiAgICBpZiAoaGlkZGVuUmVjb3JkICYmIGhpZGRlblJlY29yZC5rZXkgPT09IGtleSkgeyByZXR1cm4gaGlkZGVuUmVjb3JkOyB9XG4gICAgaWYgKCFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgLy8gV2VhayBtYXAgbXVzdCBicnV0ZSBmb3JjZSwgYXMgZXhwbGFpbmVkIGluIGRvYy1jb21tZW50IGFib3ZlLlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgaGlkZGVuUmVjb3JkIGFuZCB0aGUga2V5IHBvaW50IGRpcmVjdGx5IGF0IGVhY2ggb3RoZXIsIHZpYVxuICAgIC8vIHRoZSBcImtleVwiIGFuZCBISURERU5fTkFNRSBwcm9wZXJ0aWVzIHJlc3BlY3RpdmVseS4gVGhlIGtleVxuICAgIC8vIGZpZWxkIGlzIGZvciBxdWlja2x5IHZlcmlmeWluZyB0aGF0IHRoaXMgaGlkZGVuIHJlY29yZCBpcyBhblxuICAgIC8vIG93biBwcm9wZXJ0eSwgbm90IGEgaGlkZGVuIHJlY29yZCBmcm9tIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgLy9cbiAgICAvLyBOT1RFOiBCZWNhdXNlIHRoaXMgV2Vha01hcCBlbXVsYXRpb24gaXMgbWVhbnQgb25seSBmb3Igc3lzdGVtcyBsaWtlXG4gICAgLy8gU0VTIHdoZXJlIE9iamVjdC5wcm90b3R5cGUgaXMgZnJvemVuIHdpdGhvdXQgYW55IG51bWVyaWNcbiAgICAvLyBwcm9wZXJ0aWVzLCBpdCBpcyBvayB0byB1c2UgYW4gb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBoaWRkZW5SZWNvcmQuXG4gICAgLy8gVGhpcyBoYXMgdHdvIGFkdmFudGFnZXM6XG4gICAgLy8gKiBJdCBpcyBtdWNoIGZhc3RlciBpbiBhIHBlcmZvcm1hbmNlIGNyaXRpY2FsIHBsYWNlXG4gICAgLy8gKiBJdCBhdm9pZHMgcmVseWluZyBvbiBPYmplY3QuY3JlYXRlKG51bGwpLCB3aGljaCBoYWQgYmVlblxuICAgIC8vICAgcHJvYmxlbWF0aWMgb24gQ2hyb21lIDI4LjAuMTQ4MC4wLiBTZWVcbiAgICAvLyAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvaXNzdWVzL2RldGFpbD9pZD0xNjg3XG4gICAgaGlkZGVuUmVjb3JkID0geyBrZXk6IGtleSB9O1xuXG4gICAgLy8gV2hlbiB1c2luZyB0aGlzIFdlYWtNYXAgZW11bGF0aW9uIG9uIHBsYXRmb3JtcyB3aGVyZVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUgbWlnaHQgbm90IGJlIGZyb3plbiBhbmQgT2JqZWN0LmNyZWF0ZShudWxsKSBpc1xuICAgIC8vIHJlbGlhYmxlLCB1c2UgdGhlIGZvbGxvd2luZyB0d28gY29tbWVudGVkIG91dCBsaW5lcyBpbnN0ZWFkLlxuICAgIC8vIGhpZGRlblJlY29yZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gaGlkZGVuUmVjb3JkLmtleSA9IGtleTtcblxuICAgIC8vIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBuZWVkIHRoaXMgdG8gd29yayBvbiBwbGF0Zm9ybXMgd2hlcmVcbiAgICAvLyBPYmplY3QucHJvdG90eXBlIG1pZ2h0IG5vdCBiZSBmcm96ZW4gYW5kXG4gICAgLy8gT2JqZWN0LmNyZWF0ZShudWxsKSBtaWdodCBub3QgYmUgcmVsaWFibGUuXG5cbiAgICB0cnkge1xuICAgICAgZGVmUHJvcChrZXksIEhJRERFTl9OQU1FLCB7XG4gICAgICAgIHZhbHVlOiBoaWRkZW5SZWNvcmQsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhpZGRlblJlY29yZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBpc0V4dGVuc2libGUgc2VlbXMgdG8gbWlzcmVwb3J0IHdoZXRoZXJcbiAgICAgIC8vIHRoZSBISURERU5fTkFNRSBjYW4gYmUgZGVmaW5lZC5cbiAgICAgIC8vIFRoZSBjaXJjdW1zdGFuY2VzIGhhdmUgbm90IGJlZW4gaXNvbGF0ZWQsIGJ1dCBhdCBsZWFzdCBhZmZlY3RcbiAgICAgIC8vIE5vZGUuanMgdjAuMTAuMjYgb24gVHJhdmlzQ0kgLyBMaW51eCwgYnV0IG5vdCB0aGUgc2FtZSB2ZXJzaW9uIG9mXG4gICAgICAvLyBOb2RlLmpzIG9uIE9TIFguXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb25rZXkgcGF0Y2ggb3BlcmF0aW9ucyB0aGF0IHdvdWxkIG1ha2UgdGhlaXIgYXJndW1lbnRcbiAgICogbm9uLWV4dGVuc2libGUuXG4gICAqXG4gICAqIDxwPlRoZSBtb25rZXkgcGF0Y2hlZCB2ZXJzaW9ucyB0aHJvdyBhIFR5cGVFcnJvciBpZiB0aGVpclxuICAgKiBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0LCBzbyBpdCBzaG91bGQgb25seSBiZSBkb25lIHRvIGZ1bmN0aW9uc1xuICAgKiB0aGF0IHNob3VsZCB0aHJvdyBhIFR5cGVFcnJvciBhbnl3YXkgaWYgdGhlaXIgYXJndW1lbnQgaXMgbm90IGFuXG4gICAqIG9iamVjdC5cbiAgICovXG4gIChmdW5jdGlvbigpe1xuICAgIHZhciBvbGRGcmVlemUgPSBPYmplY3QuZnJlZXplO1xuICAgIGRlZlByb3AoT2JqZWN0LCAnZnJlZXplJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aWZ5aW5nRnJlZXplKG9iaikge1xuICAgICAgICBnZXRIaWRkZW5SZWNvcmQob2JqKTtcbiAgICAgICAgcmV0dXJuIG9sZEZyZWV6ZShvYmopO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvbGRTZWFsID0gT2JqZWN0LnNlYWw7XG4gICAgZGVmUHJvcChPYmplY3QsICdzZWFsJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aWZ5aW5nU2VhbChvYmopIHtcbiAgICAgICAgZ2V0SGlkZGVuUmVjb3JkKG9iaik7XG4gICAgICAgIHJldHVybiBvbGRTZWFsKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG9sZFByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuICAgIGRlZlByb3AoT2JqZWN0LCAncHJldmVudEV4dGVuc2lvbnMnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaWRlbnRpZnlpbmdQcmV2ZW50RXh0ZW5zaW9ucyhvYmopIHtcbiAgICAgICAgZ2V0SGlkZGVuUmVjb3JkKG9iaik7XG4gICAgICAgIHJldHVybiBvbGRQcmV2ZW50RXh0ZW5zaW9ucyhvYmopO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGNvbnN0RnVuYyhmdW5jKSB7XG4gICAgZnVuYy5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGZ1bmMpO1xuICB9XG5cbiAgdmFyIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nRG9uZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZygpIHtcbiAgICAvLyBGdXR1cmUgRVM2IFdlYWtNYXAgaXMgY3VycmVudGx5ICgyMDEzLTA5LTEwKSBleHBlY3RlZCB0byByZWplY3QgV2Vha01hcCgpXG4gICAgLy8gYnV0IHdlIHVzZWQgdG8gcGVybWl0IGl0IGFuZCBkbyBpdCBvdXJzZWx2ZXMsIHNvIHdhcm4gb25seS5cbiAgICBpZiAoIWNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nRG9uZSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nRG9uZSA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYWtNYXAgc2hvdWxkIGJlIGludm9rZWQgYXMgbmV3IFdlYWtNYXAoKSwgbm90ICcgK1xuICAgICAgICAgICdXZWFrTWFwKCkuIFRoaXMgd2lsbCBiZSBhbiBlcnJvciBpbiB0aGUgZnV0dXJlLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0SWQgPSAwO1xuXG4gIHZhciBPdXJXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE91cldlYWtNYXApKSB7ICAvLyBhcHByb3hpbWF0ZSB0ZXN0IGZvciBuZXcgLi4uKClcbiAgICAgIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gV2UgYXJlIGN1cnJlbnRseSAoMTIvMjUvMjAxMikgbmV2ZXIgZW5jb3VudGVyaW5nIGFueSBwcmVtYXR1cmVseVxuICAgIC8vIG5vbi1leHRlbnNpYmxlIGtleXMuXG4gICAgdmFyIGtleXMgPSBbXTsgLy8gYnJ1dGUgZm9yY2UgZm9yIHByZW1hdHVyZWx5IG5vbi1leHRlbnNpYmxlIGtleXMuXG4gICAgdmFyIHZhbHVlcyA9IFtdOyAvLyBicnV0ZSBmb3JjZSBmb3IgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgdmFyIGlkID0gbmV4dElkKys7XG5cbiAgICBmdW5jdGlvbiBnZXRfX18oa2V5LCBvcHRfZGVmYXVsdCkge1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgdmFyIGhpZGRlblJlY29yZCA9IGdldEhpZGRlblJlY29yZChrZXkpO1xuICAgICAgaWYgKGhpZGRlblJlY29yZCkge1xuICAgICAgICByZXR1cm4gaWQgaW4gaGlkZGVuUmVjb3JkID8gaGlkZGVuUmVjb3JkW2lkXSA6IG9wdF9kZWZhdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB2YWx1ZXNbaW5kZXhdIDogb3B0X2RlZmF1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzX19fKGtleSkge1xuICAgICAgdmFyIGhpZGRlblJlY29yZCA9IGdldEhpZGRlblJlY29yZChrZXkpO1xuICAgICAgaWYgKGhpZGRlblJlY29yZCkge1xuICAgICAgICByZXR1cm4gaWQgaW4gaGlkZGVuUmVjb3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleXMuaW5kZXhPZihrZXkpID49IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0X19fKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgaGlkZGVuUmVjb3JkW2lkXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2Ugc29tZSBicm93c2VycyBwcmVlbXB0aXZlbHkgdGVybWluYXRlIHNsb3cgdHVybnMgYnV0XG4gICAgICAgICAgLy8gdGhlbiBjb250aW51ZSBjb21wdXRpbmcgd2l0aCBwcmVzdW1hYmx5IGNvcnJ1cHRlZCBoZWFwXG4gICAgICAgICAgLy8gc3RhdGUsIHdlIGhlcmUgZGVmZW5zaXZlbHkgZ2V0IGtleXMubGVuZ3RoIGZpcnN0IGFuZCB0aGVuXG4gICAgICAgICAgLy8gdXNlIGl0IHRvIHVwZGF0ZSBib3RoIHRoZSB2YWx1ZXMgYW5kIGtleXMgYXJyYXlzLCBrZWVwaW5nXG4gICAgICAgICAgLy8gdGhlbSBpbiBzeW5jLlxuICAgICAgICAgIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIHZhbHVlcyB3aWxsIGJlIG9uZSBsb25nZXIgdGhhbiBrZXlzLlxuICAgICAgICAgIGtleXNbaW5kZXhdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVfX18oa2V5KSB7XG4gICAgICB2YXIgaGlkZGVuUmVjb3JkID0gZ2V0SGlkZGVuUmVjb3JkKGtleSk7XG4gICAgICB2YXIgaW5kZXgsIGxhc3RJbmRleDtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGlkIGluIGhpZGRlblJlY29yZCAmJiBkZWxldGUgaGlkZGVuUmVjb3JkW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc29tZSBicm93c2VycyBwcmVlbXB0aXZlbHkgdGVybWluYXRlIHNsb3cgdHVybnMgYnV0XG4gICAgICAgIC8vIHRoZW4gY29udGludWUgY29tcHV0aW5nIHdpdGggcG90ZW50aWFsbHkgY29ycnVwdGVkIGhlYXBcbiAgICAgICAgLy8gc3RhdGUsIHdlIGhlcmUgZGVmZW5zaXZlbHkgZ2V0IGtleXMubGVuZ3RoIGZpcnN0IGFuZCB0aGVuIHVzZVxuICAgICAgICAvLyBpdCB0byB1cGRhdGUgYm90aCB0aGUga2V5cyBhbmQgdGhlIHZhbHVlcyBhcnJheSwga2VlcGluZ1xuICAgICAgICAvLyB0aGVtIGluIHN5bmMuIFdlIHVwZGF0ZSB0aGUgdHdvIHdpdGggYW4gb3JkZXIgb2YgYXNzaWdubWVudHMsXG4gICAgICAgIC8vIHN1Y2ggdGhhdCBhbnkgcHJlZml4IG9mIHRoZXNlIGFzc2lnbm1lbnRzIHdpbGwgcHJlc2VydmUgdGhlXG4gICAgICAgIC8vIGtleS92YWx1ZSBjb3JyZXNwb25kZW5jZSwgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgZGVsZXRlLlxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBuZWVkcyB0byB3b3JrIGNvcnJlY3RseSB3aGVuIGluZGV4ID09PSBsYXN0SW5kZXguXG4gICAgICAgIGxhc3RJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgICAga2V5c1tpbmRleF0gPSB2b2lkIDA7XG4gICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIHRoZXJlJ3MgYSB2b2lkIDAgaW4gdGhlIGtleXMgYXJyYXksIGJ1dFxuICAgICAgICAvLyBubyBvcGVyYXRpb24gd2lsbCBjYXVzZSBhIFwia2V5cy5pbmRleE9mKHZvaWQgMClcIiwgc2luY2VcbiAgICAgICAgLy8gZ2V0SGlkZGVuUmVjb3JkKHZvaWQgMCkgd2lsbCBhbHdheXMgdGhyb3cgYW4gZXJyb3IgZmlyc3QuXG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gSWYgd2UgY3Jhc2ggaGVyZSwgdmFsdWVzW2luZGV4XSBjYW5ub3QgYmUgZm91bmQgaGVyZSxcbiAgICAgICAgLy8gYmVjYXVzZSBrZXlzW2luZGV4XSBpcyB2b2lkIDAuXG4gICAgICAgIGtleXNbaW5kZXhdID0ga2V5c1tsYXN0SW5kZXhdO1xuICAgICAgICAvLyBJZiBpbmRleCA9PT0gbGFzdEluZGV4IGFuZCB3ZSBjcmFzaCBoZXJlLCB0aGVuIGtleXNbaW5kZXhdXG4gICAgICAgIC8vIGlzIHN0aWxsIHZvaWQgMCwgc2luY2UgdGhlIGFsaWFzaW5nIGtpbGxlZCB0aGUgcHJldmlvdXMga2V5LlxuICAgICAgICBrZXlzLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICAgICAgLy8gSWYgd2UgY3Jhc2ggaGVyZSwga2V5cyB3aWxsIGJlIG9uZSBzaG9ydGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbGFzdEluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShPdXJXZWFrTWFwLnByb3RvdHlwZSwge1xuICAgICAgZ2V0X19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoZ2V0X19fKSB9LFxuICAgICAgaGFzX19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoaGFzX19fKSB9LFxuICAgICAgc2V0X19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoc2V0X19fKSB9LFxuICAgICAgZGVsZXRlX19fOiB7IHZhbHVlOiBjb25zdEZ1bmMoZGVsZXRlX19fKSB9XG4gICAgfSk7XG4gIH07XG5cbiAgT3VyV2Vha01hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIHtcbiAgICBnZXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IGFzc29jaWF0ZWQgd2l0aCBrZXksIG9yXG4gICAgICAgKiBvcHRfZGVmYXVsdCBpZiBub25lLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwgb3B0X2RlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X19fKGtleSwgb3B0X2RlZmF1bHQpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgIGhhczoge1xuICAgICAgLyoqXG4gICAgICAgKiBJcyB0aGVyZSBhIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBrZXkgaW4gdGhpcyBXZWFrTWFwP1xuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNfX18oa2V5KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBzZXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQXNzb2NpYXRlIHZhbHVlIHdpdGgga2V5IGluIHRoaXMgV2Vha01hcCwgb3ZlcndyaXRpbmcgYW55XG4gICAgICAgKiBwcmV2aW91cyBhc3NvY2lhdGlvbiBpZiBwcmVzZW50LlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0X19fKGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgICdkZWxldGUnOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbnkgYXNzb2NpYXRpb24gZm9yIGtleSBpbiB0aGlzIFdlYWtNYXAsIHJldHVybmluZ1xuICAgICAgICogd2hldGhlciB0aGVyZSB3YXMgb25lLlxuICAgICAgICpcbiAgICAgICAqIDxwPk5vdGUgdGhhdCB0aGUgYm9vbGVhbiByZXR1cm4gaGVyZSBkb2VzIG5vdCB3b3JrIGxpa2UgdGhlXG4gICAgICAgKiB7QGNvZGUgZGVsZXRlfSBvcGVyYXRvci4gVGhlIHtAY29kZSBkZWxldGV9IG9wZXJhdG9yIHJldHVybnNcbiAgICAgICAqIHdoZXRoZXIgdGhlIGRlbGV0aW9uIHN1Y2NlZWRzIGF0IGJyaW5naW5nIGFib3V0IGEgc3RhdGUgaW5cbiAgICAgICAqIHdoaWNoIHRoZSBkZWxldGVkIHByb3BlcnR5IGlzIGFic2VudC4gVGhlIHtAY29kZSBkZWxldGV9XG4gICAgICAgKiBvcGVyYXRvciB0aGVyZWZvcmUgcmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSB3YXMgYWxyZWFkeVxuICAgICAgICogYWJzZW50LCB3aGVyZWFzIHRoaXMge0Bjb2RlIGRlbGV0ZX0gbWV0aG9kIHJldHVybnMgZmFsc2UgaWZcbiAgICAgICAqIHRoZSBhc3NvY2lhdGlvbiB3YXMgYWxyZWFkeSBhYnNlbnQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZV9fXyhrZXkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAodHlwZW9mIEhvc3RXZWFrTWFwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZW4gdGhlIHBsYXRmb3JtIGhhcyBhIFdlYWtNYXAgYnV0IHdlIGFyZSBjb25jZXJuZWRcbiAgICAgIC8vIHRoYXQgaXQgbWF5IHJlZnVzZSB0byBzdG9yZSBzb21lIGtleSB0eXBlcy4gVGhlcmVmb3JlLCBtYWtlIGEgbWFwXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiB3aGljaCBtYWtlcyB1c2Ugb2YgYm90aCBhcyBwb3NzaWJsZS5cblxuICAgICAgLy8gSW4gdGhpcyBtb2RlIHdlIGFyZSBhbHdheXMgdXNpbmcgZG91YmxlIG1hcHMsIHNvIHdlIGFyZSBub3QgcHJveHktc2FmZS5cbiAgICAgIC8vIFRoaXMgY29tYmluYXRpb24gZG9lcyBub3Qgb2NjdXIgaW4gYW55IGtub3duIGJyb3dzZXIsIGJ1dCB3ZSBoYWQgYmVzdFxuICAgICAgLy8gYmUgc2FmZS5cbiAgICAgIGlmIChkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUHJveHkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIERvdWJsZVdlYWtNYXAoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPdXJXZWFrTWFwKSkgeyAgLy8gYXBwcm94aW1hdGUgdGVzdCBmb3IgbmV3IC4uLigpXG4gICAgICAgICAgY2FsbGVkQXNGdW5jdGlvbldhcm5pbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZWZlcmFibGUsIHRydWx5IHdlYWsgbWFwLlxuICAgICAgICB2YXIgaG1hcCA9IG5ldyBIb3N0V2Vha01hcCgpO1xuXG4gICAgICAgIC8vIE91ciBoaWRkZW4tcHJvcGVydHktYmFzZWQgcHNldWRvLXdlYWstbWFwLiBMYXppbHkgaW5pdGlhbGl6ZWQgaW4gdGhlXG4gICAgICAgIC8vICdzZXQnIGltcGxlbWVudGF0aW9uOyB0aHVzIHdlIGNhbiBhdm9pZCBwZXJmb3JtaW5nIGV4dHJhIGxvb2t1cHMgaWZcbiAgICAgICAgLy8gd2Uga25vdyBhbGwgZW50cmllcyBhY3R1YWxseSBzdG9yZWQgYXJlIGVudGVyZWQgaW4gJ2htYXAnLlxuICAgICAgICB2YXIgb21hcCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBIaWRkZW4tcHJvcGVydHkgbWFwcyBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBwcm94aWVzIGJlY2F1c2UgcHJveGllc1xuICAgICAgICAvLyBjYW4gb2JzZXJ2ZSB0aGUgaGlkZGVuIG5hbWUgYW5kIGVpdGhlciBhY2NpZGVudGFsbHkgZXhwb3NlIGl0IG9yIGZhaWxcbiAgICAgICAgLy8gdG8gYWxsb3cgdGhlIGhpZGRlbiBwcm9wZXJ0eSB0byBiZSBzZXQuIFRoZXJlZm9yZSwgd2UgZG8gbm90IGFsbG93XG4gICAgICAgIC8vIGFyYml0cmFyeSBXZWFrTWFwcyB0byBzd2l0Y2ggdG8gdXNpbmcgaGlkZGVuIHByb3BlcnRpZXMsIGJ1dCBvbmx5XG4gICAgICAgIC8vIHRob3NlIHdoaWNoIG5lZWQgdGhlIGFiaWxpdHksIGFuZCB1bnByaXZpbGVnZWQgY29kZSBpcyBub3QgYWxsb3dlZFxuICAgICAgICAvLyB0byBzZXQgdGhlIGZsYWcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIChFeGNlcHQgaW4gZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSBtb2RlIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAgICAgLy8gZGlzYWJsZSBwcm94aWVzLilcbiAgICAgICAgdmFyIGVuYWJsZVN3aXRjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRnZXQoa2V5LCBvcHRfZGVmYXVsdCkge1xuICAgICAgICAgIGlmIChvbWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gaG1hcC5oYXMoa2V5KSA/IGhtYXAuZ2V0KGtleSlcbiAgICAgICAgICAgICAgICA6IG9tYXAuZ2V0X19fKGtleSwgb3B0X2RlZmF1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG1hcC5nZXQoa2V5LCBvcHRfZGVmYXVsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGhhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gaG1hcC5oYXMoa2V5KSB8fCAob21hcCA/IG9tYXAuaGFzX19fKGtleSkgOiBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHNldDtcbiAgICAgICAgaWYgKGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUpIHtcbiAgICAgICAgICBkc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWhtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFvbWFwKSB7IG9tYXAgPSBuZXcgT3VyV2Vha01hcCgpOyB9XG4gICAgICAgICAgICAgIG9tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN3aXRjaGluZykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbWFwKSB7IG9tYXAgPSBuZXcgT3VyV2Vha01hcCgpOyB9XG4gICAgICAgICAgICAgICAgb21hcC5zZXRfX18oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRkZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICEhaG1hcFsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgICBpZiAob21hcCkgeyByZXR1cm4gb21hcC5kZWxldGVfX18oa2V5KSB8fCByZXN1bHQ7IH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT3VyV2Vha01hcC5wcm90b3R5cGUsIHtcbiAgICAgICAgICBnZXRfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhkZ2V0KSB9LFxuICAgICAgICAgIGhhc19fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGRoYXMpIH0sXG4gICAgICAgICAgc2V0X19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoZHNldCkgfSxcbiAgICAgICAgICBkZWxldGVfX186IHsgdmFsdWU6IGNvbnN0RnVuYyhkZGVsZXRlKSB9LFxuICAgICAgICAgIHBlcm1pdEhvc3RPYmplY3RzX19fOiB7IHZhbHVlOiBjb25zdEZ1bmMoZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gd2Vha01hcFBlcm1pdEhvc3RPYmplY3RzKSB7XG4gICAgICAgICAgICAgIGVuYWJsZVN3aXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvZ3VzIGNhbGwgdG8gcGVybWl0SG9zdE9iamVjdHNfX18nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KX1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBEb3VibGVXZWFrTWFwLnByb3RvdHlwZSA9IE91cldlYWtNYXAucHJvdG90eXBlO1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBEb3VibGVXZWFrTWFwO1xuXG4gICAgICAvLyBkZWZpbmUgLmNvbnN0cnVjdG9yIHRvIGhpZGUgT3VyV2Vha01hcCBjdG9yXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2Vha01hcC5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgICAgICAgdmFsdWU6IFdlYWtNYXAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLCAgLy8gYXMgZGVmYXVsdCAuY29uc3RydWN0b3IgaXNcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBob3N0IFdlYWtNYXAsIHNvIHdlIG11c3QgdXNlIHRoZSBlbXVsYXRpb24uXG5cbiAgICAvLyBFbXVsYXRlZCBXZWFrTWFwcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggbmF0aXZlIHByb3hpZXMgKGJlY2F1c2UgcHJveGllc1xuICAgIC8vIGNhbiBvYnNlcnZlIHRoZSBoaWRkZW4gbmFtZSksIHNvIHdlIG11c3QgZGlzYWJsZSBQcm94eSB1c2FnZSAoaW5cbiAgICAvLyBBcnJheUxpa2UgYW5kIERvbWFkbywgY3VycmVudGx5KS5cbiAgICBpZiAodHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgUHJveHkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPdXJXZWFrTWFwO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbIldlYWtNYXBNb2R1bGUiLCJzZXMiLCJvayIsIndlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cyIsIm1hcCIsInBlcm1pdEhvc3RPYmplY3RzX19fIiwiZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSIsIldlYWtNYXAiLCJIb3N0V2Vha01hcCIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJ0ZXN0TWFwIiwidGVzdE9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsInNldCIsImdldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJob3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImdvcG4iLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiaXNFeHRlbnNpYmxlIiwiSElEREVOX05BTUVfUFJFRklYIiwiSElEREVOX05BTUUiLCJNYXRoIiwicmFuZG9tIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiYWIiLCJ1OHMiLCJBcnJheSIsImNhbGwiLCJ1OCIsInRvU3RyaW5nIiwiam9pbiIsImlzTm90SGlkZGVuTmFtZSIsIm5hbWUiLCJzdWJzdHIiLCJsZW5ndGgiLCJ2YWx1ZSIsImZha2VHZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JqIiwiZmlsdGVyIiwib3JpZ2luYWxHZXRQcm9wZXJ0eU5hbWVzIiwiZ2V0UHJvcGVydHlOYW1lcyIsImZha2VHZXRQcm9wZXJ0eU5hbWVzIiwiZ2V0SGlkZGVuUmVjb3JkIiwia2V5IiwiVHlwZUVycm9yIiwiaGlkZGVuUmVjb3JkIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZXJyb3IiLCJvbGRGcmVlemUiLCJpZGVudGlmeWluZ0ZyZWV6ZSIsIm9sZFNlYWwiLCJzZWFsIiwiaWRlbnRpZnlpbmdTZWFsIiwib2xkUHJldmVudEV4dGVuc2lvbnMiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImlkZW50aWZ5aW5nUHJldmVudEV4dGVuc2lvbnMiLCJjb25zdEZ1bmMiLCJmdW5jIiwiY2FsbGVkQXNGdW5jdGlvbldhcm5pbmdEb25lIiwiY2FsbGVkQXNGdW5jdGlvbldhcm5pbmciLCJjb25zb2xlIiwid2FybiIsIm5leHRJZCIsIk91cldlYWtNYXAiLCJrZXlzIiwidmFsdWVzIiwiaWQiLCJnZXRfX18iLCJvcHRfZGVmYXVsdCIsImluZGV4IiwiaW5kZXhPZiIsImhhc19fXyIsInNldF9fXyIsImRlbGV0ZV9fXyIsImxhc3RJbmRleCIsImNyZWF0ZSIsImhhcyIsInJlbW92ZSIsIlByb3h5IiwidW5kZWZpbmVkIiwiRG91YmxlV2Vha01hcCIsImhtYXAiLCJvbWFwIiwiZW5hYmxlU3dpdGNoaW5nIiwiZGdldCIsImRoYXMiLCJkc2V0IiwiZSIsImRkZWxldGUiLCJyZXN1bHQiLCJ0b2tlbiIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/weak-map/weak-map.js\n");

/***/ })

};
;