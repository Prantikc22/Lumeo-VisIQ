"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/q";
exports.ids = ["vendor-chunks/q"];
exports.modules = {

/***/ "(rsc)/../../node_modules/q/q.js":
/*!*********************************!*\
  !*** ../../node_modules/q/q.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* vim:ts=4:sts=4:sw=4: */ /*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ /*global -WeakMap */ \nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\nvar WeakMap = __webpack_require__(/*! weak-map */ \"(rsc)/../../node_modules/weak-map/weak-map.js\");\nvar iterate = __webpack_require__(/*! pop-iterate */ \"(rsc)/../../node_modules/pop-iterate/pop-iterate.js\");\nvar asap = __webpack_require__(/*! asap */ \"(rsc)/../../node_modules/asap/asap.js\");\nfunction isObject(value) {\n    return value === Object(value);\n}\n// long stack traces\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {\n        var stacks = [];\n        for(var p = promise; !!p && handlers.get(p); p = handlers.get(p).became){\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\nfunction filterStackString(stackString) {\n    if (Q.isIntrospective) {\n        return stackString;\n    }\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for(var i = 0; i < lines.length; ++i){\n        var line = lines[i];\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n}\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [\n            attempt1[1],\n            Number(attempt1[2])\n        ];\n    }\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [\n            attempt2[1],\n            Number(attempt2[2])\n        ];\n    }\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [\n            attempt3[1],\n            Number(attempt3[2])\n        ];\n    }\n}\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n    return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n}\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\nfunction deprecate(callback, name1, alternative) {\n    return function Q_deprecate() {\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            if (alternative) {\n                console.warn(name1 + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n            } else {\n                console.warn(name1 + \" is deprecated.\", new Error(\"\").stack);\n            }\n        }\n        return callback.apply(this, arguments);\n    };\n}\n// end of long stack traces\nvar handlers = new WeakMap();\nfunction Q_getHandler(promise) {\n    var handler = handlers.get(promise);\n    if (!handler || !handler.became) {\n        return handler;\n    }\n    handler = follow(handler);\n    handlers.set(promise, handler);\n    return handler;\n}\nfunction follow(handler) {\n    if (!handler.became) {\n        return handler;\n    } else {\n        handler.became = follow(handler.became);\n        return handler.became;\n    }\n}\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\nvar thenables = new WeakMap();\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */ module.exports = Q;\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (Q_isPromise(value)) {\n        return value;\n    } else if (isThenable(value)) {\n        if (!thenables.has(value)) {\n            thenables.set(value, new Promise(new Thenable(value)));\n        }\n        return thenables.get(value);\n    } else {\n        return new Promise(new Fulfilled(value));\n    }\n}\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */ Q.longStackSupport = false;\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */ Q.reject = Q_reject;\nfunction Q_reject(error) {\n    return new Promise(new Rejected(error));\n}\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */ Q.defer = defer;\nfunction defer() {\n    var handler = new Pending();\n    var promise = new Promise(handler);\n    var deferred = new Deferred(promise);\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n    return deferred;\n}\n// TODO\n/**\n */ Q.when = function Q_when(value, fulfilled, rejected, ms) {\n    return Q(value).then(fulfilled, rejected, ms);\n};\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */ // By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = Q_all;\nfunction Q_all(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n        }\n        return Q(questions).all();\n    }\n    var countDown = 0;\n    var deferred = defer();\n    var answers = Array(questions.length);\n    var estimates = [];\n    var estimate = -Infinity;\n    var setEstimate;\n    Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n        var handler;\n        if (Q_isPromise(promise) && (handler = Q_getHandler(promise)).state === \"fulfilled\") {\n            answers[index] = handler.value;\n        } else {\n            ++countDown;\n            promise = Q(promise);\n            promise.then(function Q_all_eachFulfilled(value) {\n                answers[index] = value;\n                if (--countDown === 0) {\n                    deferred.resolve(answers);\n                }\n            }, deferred.reject);\n            promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n                var oldEstimate = estimates[index];\n                estimates[index] = newEstimate;\n                if (newEstimate > estimate) {\n                    estimate = newEstimate;\n                } else if (oldEstimate === estimate && newEstimate <= estimate) {\n                    // There is a 1/length chance that we will need to perform\n                    // this O(length) walk, so amortized O(1)\n                    computeEstimate();\n                }\n                if (estimates.length === questions.length && estimate !== setEstimate) {\n                    deferred.setEstimate(estimate);\n                    setEstimate = estimate;\n                }\n            });\n        }\n    });\n    function computeEstimate() {\n        estimate = -Infinity;\n        for(var index = 0; index < estimates.length; index++){\n            if (estimates[index] > estimate) {\n                estimate = estimates[index];\n            }\n        }\n    }\n    if (countDown === 0) {\n        deferred.resolve(answers);\n    }\n    return deferred.promise;\n}\n/**\n * @see Promise#allSettled\n */ Q.allSettled = Q_allSettled;\nfunction Q_allSettled(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n        }\n        return Q(questions).allSettled();\n    }\n    return Q_all(questions.map(function Q_allSettled_each(promise) {\n        promise = Q(promise);\n        function regardless() {\n            return promise.inspect();\n        }\n        return promise.then(regardless, regardless);\n    }));\n}\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */ Q.delay = function Q_delay(object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */ Q.timeout = function Q_timeout(object, ms, message) {\n    return Q(object).timeout(ms, message);\n};\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */ Q.spread = Q_spread;\nfunction Q_spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */ Q.join = function Q_join(x, y) {\n    return Q.spread([\n        x,\n        y\n    ], function Q_joined(x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */ Q.race = Q_race;\nfunction Q_race(answerPs) {\n    return new Promise(function(deferred) {\n        answerPs.forEach(function(answerP) {\n            Q(answerP).then(deferred.resolve, deferred.reject);\n        });\n    });\n}\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q.try = function Q_try(callback) {\n    return Q(callback).dispatch(\"call\", [\n        []\n    ]);\n};\n/**\n * TODO\n */ Q.function = Promise_function;\nfunction Promise_function(wrapped) {\n    return function promiseFunctionWrapper() {\n        var args = new Array(arguments.length);\n        for(var index = 0; index < arguments.length; index++){\n            args[index] = arguments[index];\n        }\n        return Q(wrapped).apply(this, args);\n    };\n}\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */ Q.promised = function Q_promised(callback) {\n    return function promisedMethod() {\n        var args = new Array(arguments.length);\n        for(var index = 0; index < arguments.length; index++){\n            args[index] = arguments[index];\n        }\n        return Q_spread([\n            this,\n            Q_all(args)\n        ], function Q_promised_spread(self, args) {\n            return callback.apply(self, args);\n        });\n    };\n};\n/**\n */ Q.passByCopy = Q.push = function(value) {\n    if (Object(value) === value && !Q_isPromise(value)) {\n        passByCopies.set(value, true);\n    }\n    return value;\n};\nQ.isPortable = function(value) {\n    return Object(value) === value && passByCopies.has(value);\n};\nvar passByCopies = new WeakMap();\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */ Q.async = Q_async;\nfunction Q_async(makeGenerator) {\n    return function spawn() {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var iteration;\n            try {\n                iteration = generator[verb](arg);\n            } catch (exception) {\n                return Q_reject(exception);\n            }\n            if (iteration.done) {\n                return Q(iteration.value);\n            } else {\n                return Q(iteration.value).then(callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */ Q.spawn = Q_spawn;\nfunction Q_spawn(makeGenerator) {\n    Q_async(makeGenerator)().done();\n}\n// Thus begins the section dedicated to the Promise\n/**\n * TODO\n */ Q.Promise = Promise;\nfunction Promise(handler) {\n    if (!(this instanceof Promise)) {\n        return new Promise(handler);\n    }\n    if (typeof handler === \"function\") {\n        var setup = handler;\n        var deferred = defer();\n        handler = Q_getHandler(deferred.promise);\n        try {\n            setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n        } catch (error) {\n            deferred.reject(error);\n        }\n    }\n    handlers.set(this, handler);\n}\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */ Promise.all = Q_all;\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */ Promise.race = Q_race;\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */ Promise.resolve = Promise_resolve;\nfunction Promise_resolve(value) {\n    return Q(value);\n}\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */ Promise.reject = Q_reject;\n/**\n * @returns {boolean} whether the given value is a promise.\n */ Q.isPromise = Q_isPromise;\nfunction Q_isPromise(object) {\n    return isObject(object) && !!handlers.get(object);\n}\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */ function isThenable(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */ Promise.prototype.inspect = function Promise_inspect() {\n    // the second layer captures only the relevant \"state\" properties of the\n    // handler to prevent leaking the capability to access or alter the\n    // handler.\n    return Q_getHandler(this).inspect();\n};\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */ Promise.prototype.isPending = function Promise_isPending() {\n    return Q_getHandler(this).state === \"pending\";\n};\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */ Promise.prototype.isFulfilled = function Promise_isFulfilled() {\n    return Q_getHandler(this).state === \"fulfilled\";\n};\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */ Promise.prototype.isRejected = function Promise_isRejected() {\n    return Q_getHandler(this).state === \"rejected\";\n};\n/**\n * TODO\n */ Promise.prototype.toBePassed = function Promise_toBePassed() {\n    return Q_getHandler(this).state === \"passed\";\n};\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */ Promise.prototype.toString = function Promise_toString() {\n    return \"[object Promise]\";\n};\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */ Promise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n    var self = this;\n    var deferred = defer();\n    var _fulfilled;\n    if (typeof fulfilled === \"function\") {\n        _fulfilled = function Promise_then_fulfilled(value) {\n            try {\n                deferred.resolve(fulfilled.call(void 0, value));\n            } catch (error) {\n                deferred.reject(error);\n            }\n        };\n    } else {\n        _fulfilled = deferred.resolve;\n    }\n    var _rejected;\n    if (typeof rejected === \"function\") {\n        _rejected = function Promise_then_rejected(error) {\n            try {\n                deferred.resolve(rejected.call(void 0, error));\n            } catch (newError) {\n                deferred.reject(newError);\n            }\n        };\n    } else {\n        _rejected = deferred.reject;\n    }\n    this.done(_fulfilled, _rejected);\n    if (ms !== void 0) {\n        var updateEstimate = function Promise_then_updateEstimate() {\n            deferred.setEstimate(self.getEstimate() + ms);\n        };\n        this.observeEstimate(updateEstimate);\n        updateEstimate();\n    }\n    return deferred.promise;\n};\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */ Promise.prototype.done = function Promise_done(fulfilled, rejected) {\n    var self = this;\n    var done = false; // ensure the untrusted promise makes at most a\n    // single call to one of the callbacks\n    asap(function Promise_done_task() {\n        var _fulfilled;\n        if (typeof fulfilled === \"function\") {\n            if (Q.onerror) {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    try {\n                        fulfilled.call(void 0, value);\n                    } catch (error) {\n                        // fallback to rethrow is still necessary because\n                        // _fulfilled is not called in the same event as the\n                        // above guard.\n                        (Q.onerror || Promise_rethrow)(error);\n                    }\n                };\n            } else {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    fulfilled.call(void 0, value);\n                };\n            }\n        }\n        var _rejected;\n        if (typeof rejected === \"function\" && Q.onerror) {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                try {\n                    rejected.call(void 0, error);\n                } catch (newError) {\n                    (Q.onerror || Promise_rethrow)(newError);\n                }\n            };\n        } else if (typeof rejected === \"function\") {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                rejected.call(void 0, error);\n            };\n        } else {\n            _rejected = Q.onerror || Promise_rethrow;\n        }\n        if (typeof process === \"object\" && process.domain) {\n            _rejected = process.domain.bind(_rejected);\n        }\n        Q_getHandler(self).dispatch(_fulfilled, \"then\", [\n            _rejected\n        ]);\n    });\n};\nfunction Promise_rethrow(error) {\n    throw error;\n}\n/**\n * TODO\n */ Promise.prototype.thenResolve = function Promise_thenResolve(value) {\n    // Wrapping ahead of time to forestall multiple wrappers.\n    value = Q(value);\n    // Using all is necessary to aggregate the estimated time to completion.\n    return Q_all([\n        this,\n        value\n    ]).then(function Promise_thenResolve_resolved() {\n        return value;\n    }, null, 0);\n// 0: does not contribute significantly to the estimated time to\n// completion.\n};\n/**\n * TODO\n */ Promise.prototype.thenReject = function Promise_thenReject(error) {\n    return this.then(function Promise_thenReject_resolved() {\n        throw error;\n    }, null, 0);\n// 0: does not contribute significantly to the estimated time to\n// completion.\n};\n/**\n * TODO\n */ Promise.prototype.all = function Promise_all() {\n    return this.then(Q_all);\n};\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */ Promise.prototype.allSettled = function Promise_allSettled() {\n    return this.then(Q_allSettled);\n};\n/**\n * TODO\n */ Promise.prototype.catch = function Promise_catch(rejected) {\n    return this.then(void 0, rejected);\n};\n/**\n * TODO\n */ Promise.prototype.finally = function Promise_finally(callback, ms) {\n    if (!callback) {\n        return this;\n    }\n    callback = Q(callback);\n    return this.then(function(value) {\n        return callback.call().then(function Promise_finally_fulfilled() {\n            return value;\n        });\n    }, function(reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.call().then(function Promise_finally_rejected() {\n            throw reason;\n        });\n    }, ms);\n};\n/**\n * TODO\n */ Promise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n    this.rawDispatch(null, \"estimate\", [\n        emit\n    ]);\n    return this;\n};\n/**\n * TODO\n */ Promise.prototype.getEstimate = function Promise_getEstimate() {\n    return Q_getHandler(this).estimate;\n};\n/**\n * TODO\n */ Promise.prototype.dispatch = function Promise_dispatch(op, args) {\n    var deferred = defer();\n    this.rawDispatch(deferred.resolve, op, args);\n    return deferred.promise;\n};\n/**\n */ Promise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n    var self = this;\n    asap(function Promise_dispatch_task() {\n        Q_getHandler(self).dispatch(resolve, op, args);\n    });\n};\n/**\n * TODO\n */ Promise.prototype.get = function Promise_get(name1) {\n    return this.dispatch(\"get\", [\n        name1\n    ]);\n};\n/**\n * TODO\n */ Promise.prototype.invoke = function Promise_invoke(name1 /*...args*/ ) {\n    var args = new Array(arguments.length - 1);\n    for(var index = 1; index < arguments.length; index++){\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"invoke\", [\n        name1,\n        args\n    ]);\n};\n/**\n * TODO\n */ Promise.prototype.apply = function Promise_apply(thisp, args) {\n    return this.dispatch(\"call\", [\n        args,\n        thisp\n    ]);\n};\n/**\n * TODO\n */ Promise.prototype.call = function Promise_call(thisp /*, ...args*/ ) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for(var index = 1; index < arguments.length; index++){\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"call\", [\n        args,\n        thisp\n    ]);\n};\n/**\n * TODO\n */ Promise.prototype.bind = function Promise_bind(thisp /*, ...args*/ ) {\n    var self = this;\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for(var index = 1; index < arguments.length; index++){\n        args[index - 1] = arguments[index];\n    }\n    return function Promise_bind_bound() {\n        var boundArgs = args.slice();\n        for(var index = 0; index < arguments.length; index++){\n            boundArgs[boundArgs.length] = arguments[index];\n        }\n        return self.dispatch(\"call\", [\n            boundArgs,\n            thisp\n        ]);\n    };\n};\n/**\n * TODO\n */ Promise.prototype.keys = function Promise_keys() {\n    return this.dispatch(\"keys\", []);\n};\n/**\n * TODO\n */ Promise.prototype.iterate = function Promise_iterate() {\n    return this.dispatch(\"iterate\", []);\n};\n/**\n * TODO\n */ Promise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n    return this.all().then(function Promise_spread_fulfilled(array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected, ms);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */ Promise.prototype.timeout = function Promsie_timeout(ms, message) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function Promise_timeout_task() {\n        deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n    }, ms);\n    this.then(function Promise_timeout_fulfilled(value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function Promise_timeout_rejected(error) {\n        clearTimeout(timeoutId);\n        deferred.reject(error);\n    });\n    return deferred.promise;\n};\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */ Promise.prototype.delay = function Promise_delay(ms) {\n    return this.then(function Promise_delay_fulfilled(value) {\n        var deferred = defer();\n        deferred.setEstimate(Date.now() + ms);\n        setTimeout(function Promise_delay_task() {\n            deferred.resolve(value);\n        }, ms);\n        return deferred.promise;\n    }, null, ms);\n};\n/**\n * TODO\n */ Promise.prototype.pull = function Promise_pull() {\n    return this.dispatch(\"pull\", []);\n};\n/**\n * TODO\n */ Promise.prototype.pass = function Promise_pass() {\n    if (!this.toBePassed()) {\n        return new Promise(new Passed(this));\n    } else {\n        return this;\n    }\n};\n// Thus begins the portion dedicated to the deferred\nvar promises = new WeakMap();\nfunction Deferred(promise) {\n    this.promise = promise;\n    // A deferred has an intrinsic promise, denoted by its hidden handler\n    // property.  The promise property of the deferred may be assigned to a\n    // different promise (as it is in a Queue), but the intrinsic promise does\n    // not change.\n    promises.set(this, promise);\n    var self = this;\n    var resolve = this.resolve;\n    this.resolve = function(value) {\n        resolve.call(self, value);\n    };\n    var reject = this.reject;\n    this.reject = function(error) {\n        reject.call(self, error);\n    };\n}\n/**\n * TODO\n */ Deferred.prototype.resolve = function Deferred_resolve(value) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q(value));\n};\n/**\n * TODO\n */ Deferred.prototype.reject = function Deferred_reject(reason) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q_reject(reason));\n};\n/**\n * TODO\n */ Deferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n    estimate = +estimate;\n    if (estimate !== estimate) {\n        estimate = Infinity;\n    }\n    if (estimate < 1e12 && estimate !== -Infinity) {\n        throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n    }\n    var handler = Q_getHandler(promises.get(this));\n    // TODO There is a bit of capability leakage going on here. The Deferred\n    // should only be able to set the estimate for its original\n    // Pending, not for any handler that promise subsequently became.\n    if (handler.setEstimate) {\n        handler.setEstimate(estimate);\n    }\n};\n// Thus ends the public interface\n// Thus begins the portion dedicated to handlers\nfunction Fulfilled(value) {\n    this.value = value;\n    this.estimate = Date.now();\n}\nFulfilled.prototype.state = \"fulfilled\";\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n    return {\n        state: \"fulfilled\",\n        value: this.value\n    };\n};\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(resolve, op, operands) {\n    var result;\n    if (op === \"then\" || op === \"get\" || op === \"call\" || op === \"invoke\" || op === \"keys\" || op === \"iterate\" || op === \"pull\") {\n        try {\n            result = this[op].apply(this, operands);\n        } catch (exception) {\n            result = Q_reject(exception);\n        }\n    } else if (op === \"estimate\") {\n        operands[0].call(void 0, this.estimate);\n    } else {\n        var error = new Error(\"Fulfilled promises do not support the \" + op + \" operator\");\n        result = Q_reject(error);\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\nFulfilled.prototype.then = function Fulfilled_then() {\n    return this.value;\n};\nFulfilled.prototype.get = function Fulfilled_get(name1) {\n    return this.value[name1];\n};\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n    return this.callInvoke(this.value, args, thisp);\n};\nFulfilled.prototype.invoke = function Fulfilled_invoke(name1, args) {\n    return this.callInvoke(this.value[name1], args, this.value);\n};\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n    var waitToBePassed;\n    for(var index = 0; index < args.length; index++){\n        if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n            waitToBePassed = waitToBePassed || [];\n            waitToBePassed.push(args[index]);\n        }\n    }\n    if (waitToBePassed) {\n        var self = this;\n        return Q_all(waitToBePassed).then(function() {\n            return self.callInvoke(callback, args.map(function(arg) {\n                if (Q_isPromise(arg) && arg.toBePassed()) {\n                    return arg.inspect().value;\n                } else {\n                    return arg;\n                }\n            }), thisp);\n        });\n    } else {\n        return callback.apply(thisp, args);\n    }\n};\nFulfilled.prototype.keys = function Fulfilled_keys() {\n    return Object.keys(this.value);\n};\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n    return iterate(this.value);\n};\nFulfilled.prototype.pull = function Fulfilled_pull() {\n    var result;\n    if (Object(this.value) === this.value) {\n        result = Array.isArray(this.value) ? [] : {};\n        for(var name1 in this.value){\n            result[name1] = this.value[name1];\n        }\n    } else {\n        result = this.value;\n    }\n    return Q.push(result);\n};\nfunction Rejected(reason) {\n    this.reason = reason;\n    this.estimate = Infinity;\n}\nRejected.prototype.state = \"rejected\";\nRejected.prototype.inspect = function Rejected_inspect() {\n    return {\n        state: \"rejected\",\n        reason: this.reason\n    };\n};\nRejected.prototype.dispatch = function Rejected_dispatch(resolve, op, operands) {\n    var result;\n    if (op === \"then\") {\n        result = this.then(resolve, operands[0]);\n    } else {\n        result = this;\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\nRejected.prototype.then = function Rejected_then(resolve, rejected) {\n    return rejected ? rejected(this.reason) : this;\n};\nfunction Pending() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    this.messages = [];\n    this.observers = [];\n    this.estimate = Infinity;\n}\nPending.prototype.state = \"pending\";\nPending.prototype.inspect = function Pending_inspect() {\n    return {\n        state: \"pending\"\n    };\n};\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n    this.messages.push([\n        resolve,\n        op,\n        operands\n    ]);\n    if (op === \"estimate\") {\n        this.observers.push(operands[0]);\n        var self = this;\n        asap(function Pending_dispatch_task() {\n            operands[0].call(void 0, self.estimate);\n        });\n    }\n};\nPending.prototype.become = function Pending_become(promise) {\n    this.became = theViciousCycle;\n    var handler = Q_getHandler(promise);\n    this.became = handler;\n    handlers.set(promise, handler);\n    this.promise = void 0;\n    this.messages.forEach(function Pending_become_eachMessage(message) {\n        // makeQ does not have this asap call, so it must be queueing events\n        // downstream. TODO look at makeQ to ascertain\n        asap(function Pending_become_eachMessage_task() {\n            var handler = Q_getHandler(promise);\n            handler.dispatch.apply(handler, message);\n        });\n    });\n    this.messages = void 0;\n    this.observers = void 0;\n};\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n    if (this.observers) {\n        var self = this;\n        self.estimate = estimate;\n        this.observers.forEach(function Pending_eachObserver(observer) {\n            asap(function Pending_setEstimate_eachObserver_task() {\n                observer.call(void 0, estimate);\n            });\n        });\n    }\n};\nfunction Thenable(thenable) {\n    this.thenable = thenable;\n    this.became = null;\n    this.estimate = Infinity;\n}\nThenable.prototype.state = \"thenable\";\nThenable.prototype.inspect = function Thenable_inspect() {\n    return {\n        state: \"pending\"\n    };\n};\nThenable.prototype.cast = function Thenable_cast() {\n    if (!this.became) {\n        var deferred = defer();\n        var thenable = this.thenable;\n        asap(function Thenable_cast_task() {\n            try {\n                thenable.then(deferred.resolve, deferred.reject);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        this.became = Q_getHandler(deferred.promise);\n    }\n    return this.became;\n};\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n    this.cast().dispatch(resolve, op, args);\n};\nfunction Passed(promise) {\n    this.promise = promise;\n}\nPassed.prototype.state = \"passed\";\nPassed.prototype.inspect = function Passed_inspect() {\n    return this.promise.inspect();\n};\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n    return this.promise.rawDispatch(resolve, op, args);\n};\n// Thus begins the Q Node.js bridge\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.ninvoke = function Q_ninvoke(object, name1 /*...args*/ ) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for(var index = 2; index < arguments.length; index++){\n        args[index - 2] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 2] = deferred.makeNodeResolver();\n    Q(object).dispatch(\"invoke\", [\n        name1,\n        args\n    ]).catch(deferred.reject);\n    return deferred.promise;\n};\nPromise.prototype.ninvoke = function Promise_ninvoke(name1 /*...args*/ ) {\n    var args = new Array(arguments.length);\n    for(var index = 1; index < arguments.length; index++){\n        args[index - 1] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 1] = deferred.makeNodeResolver();\n    this.dispatch(\"invoke\", [\n        name1,\n        args\n    ]).catch(deferred.reject);\n    return deferred.promise;\n};\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */ Q.denodeify = function Q_denodeify(callback, pattern) {\n    return function denodeified() {\n        var args = new Array(arguments.length + 1);\n        var index = 0;\n        for(; index < arguments.length; index++){\n            args[index] = arguments[index];\n        }\n        var deferred = Q.defer();\n        args[index] = deferred.makeNodeResolver(pattern);\n        Q(callback).apply(this, args).catch(deferred.reject);\n        return deferred.promise;\n    };\n};\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */ Deferred.prototype.makeNodeResolver = function(unpack) {\n    var resolve = this.resolve;\n    if (unpack === true) {\n        return function variadicNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = new Array(Math.max(0, arguments.length - 1));\n                for(var index = 1; index < arguments.length; index++){\n                    value[index - 1] = arguments[index];\n                }\n                resolve(value);\n            }\n        };\n    } else if (unpack) {\n        return function namedArgumentNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = {};\n                for(var index = 0; index < unpack.length; index++){\n                    value[unpack[index]] = arguments[index + 1];\n                }\n                resolve(value);\n            }\n        };\n    } else {\n        return function nodebackToResolver(error, value) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                resolve(value);\n            }\n        };\n    }\n};\n/**\n * TODO\n */ Promise.prototype.nodeify = function Promise_nodeify(nodeback) {\n    if (nodeback) {\n        this.done(function(value) {\n            nodeback(null, value);\n        }, nodeback);\n    } else {\n        return this;\n    }\n};\n// DEPRECATED\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\nQ.fail = deprecate(function(value, rejected) {\n    return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\nQ.fin = deprecate(function(value, regardless) {\n    return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\nQ.progress = deprecate(function(value) {\n    return value;\n}, \"Q.progress\", \"no longer supported\");\nQ.thenResolve = deprecate(function(promise, value) {\n    return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.thenReject = deprecate(function(promise, reason) {\n    return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.isPending = deprecate(function(value) {\n    return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\nQ.isFulfilled = deprecate(function(value) {\n    return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\nQ.isRejected = deprecate(function(value) {\n    return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\nQ.master = deprecate(function(value) {\n    return value;\n}, \"master\", \"no longer necessary\");\nQ.makePromise = function() {\n    throw new Error(\"makePromise is no longer supported\");\n};\nQ.dispatch = deprecate(function(value, op, operands) {\n    return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\nQ.get = deprecate(function(object, name1) {\n    return Q(object).get(name1);\n}, \"get\", \"Q(value).get\");\nQ.keys = deprecate(function(object) {\n    return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\nQ.post = deprecate(function(object, name1, args) {\n    return Q(object).post(name1, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.mapply = deprecate(function(object, name1, args) {\n    return Q(object).post(name1, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.send = deprecate(function(object, name1) {\n    return Q(object).post(name1, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\nQ.set = function() {\n    throw new Error(\"Q.set no longer supported\");\n};\nQ.delete = function() {\n    throw new Error(\"Q.delete no longer supported\");\n};\nQ.nearer = deprecate(function(value) {\n    if (Q_isPromise(value) && value.isFulfilled()) {\n        return value.inspect().value;\n    } else {\n        return value;\n    }\n}, \"nearer\", \"inspect().value (+nuances)\");\nQ.fapply = deprecate(function(callback, args) {\n    return Q(callback).dispatch(\"call\", [\n        args\n    ]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\nQ.fcall = deprecate(function(callback /*, ...args*/ ) {\n    return Q(callback).dispatch(\"call\", [\n        Array.prototype.slice.call(arguments, 1)\n    ]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\nQ.fbind = deprecate(function(object /*...args*/ ) {\n    var promise = Q(object);\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"call\", [\n            args.concat(Array.prototype.slice.call(arguments)),\n            this\n        ]);\n    };\n}, \"fbind\", \"bind with thisp\");\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\nPromise.prototype.fapply = deprecate(function(args) {\n    return this.dispatch(\"call\", [\n        args\n    ]);\n}, \"fapply\", \"apply with thisp\");\nPromise.prototype.fcall = deprecate(function() {\n    return this.dispatch(\"call\", [\n        Array.prototype.slice.call(arguments)\n    ]);\n}, \"fcall\", \"try or call with thisp\");\nPromise.prototype.fail = deprecate(function(rejected) {\n    return this.catch(rejected);\n}, \"fail\", \"catch\");\nPromise.prototype.fin = deprecate(function(regardless) {\n    return this.finally(regardless);\n}, \"fin\", \"finally\");\nPromise.prototype.set = function() {\n    throw new Error(\"Promise set no longer supported\");\n};\nPromise.prototype.delete = function() {\n    throw new Error(\"Promise delete no longer supported\");\n};\nDeferred.prototype.notify = deprecate(function() {}, \"notify\", \"no longer supported\");\nPromise.prototype.progress = deprecate(function() {\n    return this;\n}, \"progress\", \"no longer supported\");\n// alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\nPromise.prototype.mapply = deprecate(function(name1, args) {\n    return this.dispatch(\"invoke\", [\n        name1,\n        args\n    ]);\n}, \"mapply\", \"invoke\");\nPromise.prototype.fbind = deprecate(function() {\n    return Q.fbind.apply(Q, [\n        void 0\n    ].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\");\n// alternative proposed by Mark Miller, dropped in favor of invoke\nPromise.prototype.send = deprecate(function() {\n    return this.dispatch(\"invoke\", [\n        name,\n        Array.prototype.slice.call(arguments, 1)\n    ]);\n}, \"send\", \"invoke\");\n// alternative proposed by Redsandro, dropped in favor of invoke\nPromise.prototype.mcall = deprecate(function() {\n    return this.dispatch(\"invoke\", [\n        name,\n        Array.prototype.slice.call(arguments, 1)\n    ]);\n}, \"mcall\", \"invoke\");\nPromise.prototype.passByCopy = deprecate(function(value) {\n    return value;\n}, \"passByCopy\", \"Q.passByCopy\");\n// Deprecated Node.js bridge promise methods\nQ.nfapply = deprecate(function(callback, args) {\n    var deferred = Q.defer();\n    var nodeArgs = Array.prototype.slice.call(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n}, \"nfapply\");\nPromise.prototype.nfapply = deprecate(function(args) {\n    return Q.nfapply(this, args);\n}, \"nfapply\");\nQ.nfcall = deprecate(function(callback /*...args*/ ) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return Q.nfapply(callback, args);\n}, \"nfcall\");\nPromise.prototype.nfcall = deprecate(function() {\n    var args = new Array(arguments.length);\n    for(var index = 0; index < arguments.length; index++){\n        args[index] = arguments[index];\n    }\n    return Q.nfapply(this, args);\n}, \"nfcall\");\nQ.nfbind = deprecate(function(callback /*...args*/ ) {\n    var baseArgs = Array.prototype.slice.call(arguments, 1);\n    return function() {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nfbind\", \"denodeify (with caveats)\");\nPromise.prototype.nfbind = deprecate(function() {\n    var args = new Array(arguments.length);\n    for(var index = 0; index < arguments.length; index++){\n        args[index] = arguments[index];\n    }\n    return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\nQ.nbind = deprecate(function(callback, thisp /*...args*/ ) {\n    var baseArgs = Array.prototype.slice.call(arguments, 2);\n    return function() {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nbind\", \"denodeify (with caveats)\");\nQ.npost = deprecate(function(object, name1, nodeArgs) {\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"invoke\", [\n        name1,\n        nodeArgs\n    ]).catch(deferred.reject);\n    return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\nPromise.prototype.npost = deprecate(function(name1, args) {\n    return Q.npost(this, name1, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\");\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMzQixHQUFHLFNBQVM7QUFFWjBELFFBQVEyQixTQUFTLENBQUMrTyxLQUFLLEdBQUdqUyxVQUFVLFNBQVVFLEtBQUksRUFBRTBGLElBQUk7SUFDcEQsT0FBT25ILEVBQUV3VCxLQUFLLENBQUMsSUFBSSxFQUFFL1IsT0FBTTBGO0FBQy9CLEdBQUcsU0FBUztBQUVabkgsRUFBRXlULE9BQU8sR0FBR2xTLFVBQVV2QixFQUFFeVQsT0FBTyxFQUFFLFdBQVc7QUFDNUMzUSxRQUFRMkIsU0FBUyxDQUFDZ1AsT0FBTyxHQUFHbFMsVUFBVXVCLFFBQVEyQixTQUFTLENBQUMrTyxLQUFLLEVBQUUsV0FBVztBQUUxRXhULEVBQUUwVCxLQUFLLEdBQUduUyxVQUFVdkIsRUFBRThRLE9BQU8sRUFBRSxTQUFTO0FBQ3hDOVEsRUFBRTJULE1BQU0sR0FBR3BTLFVBQVV2QixFQUFFOFEsT0FBTyxFQUFFLFVBQVU7QUFDMUNoTyxRQUFRMkIsU0FBUyxDQUFDaVAsS0FBSyxHQUFHblMsVUFBVXVCLFFBQVEyQixTQUFTLENBQUNxTSxPQUFPLEVBQUUsU0FBUztBQUN4RWhPLFFBQVEyQixTQUFTLENBQUNrUCxNQUFNLEdBQUdwUyxVQUFVdUIsUUFBUTJCLFNBQVMsQ0FBQ3FNLE9BQU8sRUFBRSxVQUFVO0FBRTFFLGlFQUFpRTtBQUNqRSxJQUFJelAsY0FBYzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHZpc2l0b3JpcS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3EvcS5qcz80ZTk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIHZpbTp0cz00OnN0cz00OnN3PTQ6ICovXG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvcmF3L21hc3Rlci9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbi8qZ2xvYmFsIC1XZWFrTWFwICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc1N0YWNrcyA9IGZhbHNlO1xudHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTdGFja3MgPSAhIWUuc3RhY2s7XG59XG5cbi8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZFxuLy8gYnkgUS5cbnZhciBxU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcbnZhciBxRmlsZU5hbWU7XG5cbnZhciBXZWFrTWFwID0gcmVxdWlyZShcIndlYWstbWFwXCIpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKFwicG9wLWl0ZXJhdGVcIik7XG52YXIgYXNhcCA9IHJlcXVpcmUoXCJhc2FwXCIpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gT2JqZWN0KHZhbHVlKTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwICYmIGhhbmRsZXJzLmdldChwKTsgcCA9IGhhbmRsZXJzLmdldChwKS5iZWNhbWUpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgaWYgKFEuaXNJbnRyb3NwZWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBzdGFja1N0cmluZztcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBRX2RlcHJlY2F0ZSgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICsgXCIgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiXCIpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiXCIpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2YgbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIGhhbmRsZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gUV9nZXRIYW5kbGVyKHByb21pc2UpIHtcbiAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzLmdldChwcm9taXNlKTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgIWhhbmRsZXIuYmVjYW1lKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICBoYW5kbGVyID0gZm9sbG93KGhhbmRsZXIpO1xuICAgIGhhbmRsZXJzLnNldChwcm9taXNlLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZnVuY3Rpb24gZm9sbG93KGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIuYmVjYW1lKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXIuYmVjYW1lID0gZm9sbG93KGhhbmRsZXIuYmVjYW1lKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuYmVjYW1lO1xuICAgIH1cbn1cblxudmFyIHRoZVZpY2lvdXNDeWNsZUVycm9yID0gbmV3IEVycm9yKFwiQ2FuJ3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG52YXIgdGhlVmljaW91c0N5Y2xlUmVqZWN0aW9uID0gUV9yZWplY3QodGhlVmljaW91c0N5Y2xlRXJyb3IpO1xudmFyIHRoZVZpY2lvdXNDeWNsZSA9IFFfZ2V0SGFuZGxlcih0aGVWaWNpb3VzQ3ljbGVSZWplY3Rpb24pO1xuXG52YXIgdGhlbmFibGVzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDb2VyY2VzIGEgdmFsdWUgdG8gYSBwcm9taXNlLiBJZiB0aGUgdmFsdWUgaXMgYSBwcm9taXNlLCBwYXNzIGl0IHRocm91Z2hcbiAqIHVuYWx0ZXJlZC4gSWYgdGhlIHZhbHVlIGhhcyBhIGB0aGVuYCBtZXRob2QsIGl0IGlzIHByZXN1bWVkIHRvIGJlIGEgcHJvbWlzZVxuICogYnV0IG5vdCBvbmUgb2Ygb3VyIG93biwgc28gaXQgaXMgdHJlYXRlZCBhcyBhIOKAnHRoZW5hYmxl4oCdIHByb21pc2UgYW5kIHRoaXNcbiAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgc3RhbmRzIGZvciBpdC4gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXRcbiAqIGhhcyBhbHJlYWR5IGJlZW4gZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIHByb21pc2UsIG9iamVjdCB3aXRoIGEgdGhlbiBtZXRob2QsIG9yIGEgZnVsZmlsbG1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGUgc2FtZSBwcm9taXNlIGFzIGdpdmVuLCBvciBhIHByb21pc2UgZm9yIHRoZSBnaXZlblxuICogdmFsdWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBRO1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAoUV9pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICAgIGlmICghdGhlbmFibGVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlcy5zZXQodmFsdWUsIG5ldyBQcm9taXNlKG5ldyBUaGVuYWJsZSh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhlbmFibGVzLmdldCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKG5ldyBGdWxmaWxsZWQodmFsdWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblEubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaGFzIGJlZW4gcmVqZWN0ZWQgd2l0aCBhIHJlYXNvbiwgd2hpY2ggc2hvdWxkIGJlIGFuXG4gKiBpbnN0YW5jZSBvZiBgRXJyb3JgLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgcmVhc29uIGZvciB0aGUgZmFpbHVyZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZWplY3Rpb25cbiAqL1xuUS5yZWplY3QgPSBRX3JlamVjdDtcbmZ1bmN0aW9uIFFfcmVqZWN0KGVycm9yKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKG5ldyBSZWplY3RlZChlcnJvcikpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7e3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH19IGEgZGVmZXJyZWRcbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG5cbiAgICB2YXIgaGFuZGxlciA9IG5ldyBQZW5kaW5nKCk7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShoYW5kbGVyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQocHJvbWlzZSk7XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8vIFRPRE9cbi8qKlxuICovXG5RLndoZW4gPSBmdW5jdGlvbiBRX3doZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG1zKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgbXMpO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2YgdGhlXG4gKiBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5LjxQcm9taXNlPn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5Pn0gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBRX2FsbDtcbmZ1bmN0aW9uIFFfYWxsKHF1ZXN0aW9ucykge1xuICAgIC8vIFhYWCBkZXByZWNhdGVkIGJlaGF2aW9yXG4gICAgaWYgKFFfaXNQcm9taXNlKHF1ZXN0aW9ucykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlEuYWxsIG5vIGxvbmdlciBkaXJlY3RseSB1bndyYXBzIGEgcHJvbWlzZS4gVXNlIFEoYXJyYXkpLmFsbCgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRKHF1ZXN0aW9ucykuYWxsKCk7XG4gICAgfVxuICAgIHZhciBjb3VudERvd24gPSAwO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIGFuc3dlcnMgPSBBcnJheShxdWVzdGlvbnMubGVuZ3RoKTtcbiAgICB2YXIgZXN0aW1hdGVzID0gW107XG4gICAgdmFyIGVzdGltYXRlID0gLUluZmluaXR5O1xuICAgIHZhciBzZXRFc3RpbWF0ZTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHF1ZXN0aW9ucywgZnVuY3Rpb24gUV9hbGxfZWFjaChwcm9taXNlLCBpbmRleCkge1xuICAgICAgICB2YXIgaGFuZGxlcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgUV9pc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgIChoYW5kbGVyID0gUV9nZXRIYW5kbGVyKHByb21pc2UpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIGFuc3dlcnNbaW5kZXhdID0gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrY291bnREb3duO1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUV9hbGxfZWFjaEZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXJzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoYW5zd2Vycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcHJvbWlzZS5vYnNlcnZlRXN0aW1hdGUoZnVuY3Rpb24gUV9hbGxfZWFjaEVzdGltYXRlKG5ld0VzdGltYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEVzdGltYXRlID0gZXN0aW1hdGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZXNbaW5kZXhdID0gbmV3RXN0aW1hdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0VzdGltYXRlID4gZXN0aW1hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGUgPSBuZXdFc3RpbWF0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZEVzdGltYXRlID09PSBlc3RpbWF0ZSAmJiBuZXdFc3RpbWF0ZSA8PSBlc3RpbWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIDEvbGVuZ3RoIGNoYW5jZSB0aGF0IHdlIHdpbGwgbmVlZCB0byBwZXJmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgTyhsZW5ndGgpIHdhbGssIHNvIGFtb3J0aXplZCBPKDEpXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVFc3RpbWF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXN0aW1hdGVzLmxlbmd0aCA9PT0gcXVlc3Rpb25zLmxlbmd0aCAmJiBlc3RpbWF0ZSAhPT0gc2V0RXN0aW1hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuc2V0RXN0aW1hdGUoZXN0aW1hdGUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFc3RpbWF0ZSA9IGVzdGltYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFc3RpbWF0ZSgpIHtcbiAgICAgICAgZXN0aW1hdGUgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBlc3RpbWF0ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoZXN0aW1hdGVzW2luZGV4XSA+IGVzdGltYXRlKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGUgPSBlc3RpbWF0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdW50RG93biA9PT0gMCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGFuc3dlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IFFfYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIFFfYWxsU2V0dGxlZChxdWVzdGlvbnMpIHtcbiAgICAvLyBYWFggZGVwcmVjYXRlZCBiZWhhdmlvclxuICAgIGlmIChRX2lzUHJvbWlzZShxdWVzdGlvbnMpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJRLmFsbFNldHRsZWQgbm8gbG9uZ2VyIGRpcmVjdGx5IHVud3JhcHMgYSBwcm9taXNlLiBVc2UgUShhcnJheSkuYWxsU2V0dGxlZCgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRKHF1ZXN0aW9ucykuYWxsU2V0dGxlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gUV9hbGwocXVlc3Rpb25zLm1hcChmdW5jdGlvbiBRX2FsbFNldHRsZWRfZWFjaChwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIFFfZGVsYXkob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjdXN0b20gZXJyb3IgbWVzc2FnZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIFFfdGltZW91dChvYmplY3QsIG1zLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gUV9zcHJlYWQ7XG5mdW5jdGlvbiBRX3NwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uIFFfam9pbih4LCB5KSB7XG4gICAgcmV0dXJuIFEuc3ByZWFkKFt4LCB5XSwgZnVuY3Rpb24gUV9qb2luZWQoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBmdWxmaWxsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXl9IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuUS5yYWNlID0gUV9yYWNlO1xuZnVuY3Rpb24gUV9yYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGRlZmVycmVkKSB7XG4gICAgICAgIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAgICAgUShhbnN3ZXJQKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS50cnkgPSBmdW5jdGlvbiBRX3RyeShjYWxsYmFjaykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5kaXNwYXRjaChcImNhbGxcIiwgW1tdXSk7XG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuUS5mdW5jdGlvbiA9IFByb21pc2VfZnVuY3Rpb247XG5mdW5jdGlvbiBQcm9taXNlX2Z1bmN0aW9uKHdyYXBwZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzZUZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFEod3JhcHBlZCkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IGZ1bmN0aW9uIFFfcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzZWRNZXRob2QoKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRX3NwcmVhZChcbiAgICAgICAgICAgIFt0aGlzLCBRX2FsbChhcmdzKV0sXG4gICAgICAgICAgICBmdW5jdGlvbiBRX3Byb21pc2VkX3NwcmVhZChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG59O1xuXG4vKipcbiAqL1xuUS5wYXNzQnlDb3B5ID0gLy8gVE9ETyBYWFggZXhwZXJpbWVudGFsXG5RLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUgJiYgIVFfaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICBwYXNzQnlDb3BpZXMuc2V0KHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuUS5pc1BvcnRhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlICYmIHBhc3NCeUNvcGllcy5oYXModmFsdWUpO1xufTtcblxudmFyIHBhc3NCeUNvcGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHlcbiAqIHBhcnQgb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2VcbiAqIHN5bnRheCBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrXG4gKiBhbmQgd2lsbCBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiBgLS1oYXJtb255LWdlbmVyYXRvcnNgIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IHRoZSBmb3JtZXIsIFB5dGhvbmljIGdlbmVyYXRvcnMgdGhhdCB3ZXJlIG9ubHkgaW1wbGVtZW50ZWRcbiAqIGJ5IFNwaWRlck1vbmtleS5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IFFfYXN5bmM7XG5mdW5jdGlvbiBRX2FzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3Bhd24oKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRpb24gPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBRX3JlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbi5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFEoaXRlcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFEoaXRlcmF0aW9uLnZhbHVlKS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IFFfc3Bhd247XG5mdW5jdGlvbiBRX3NwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRX2FzeW5jKG1ha2VHZW5lcmF0b3IpKCkuZG9uZSgpO1xufVxuXG5cbi8vIFRodXMgYmVnaW5zIHRoZSBzZWN0aW9uIGRlZGljYXRlZCB0byB0aGUgUHJvbWlzZVxuXG4vKipcbiAqIFRPRE9cbiAqL1xuUS5Qcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoaGFuZGxlcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBzZXR1cCA9IGhhbmRsZXI7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGhhbmRsZXIgPSBRX2dldEhhbmRsZXIoZGVmZXJyZWQucHJvbWlzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXR1cChkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLnNldEVzdGltYXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMuc2V0KHRoaXMsIGhhbmRsZXIpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZiB0aGVcbiAqIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkuPFByb21pc2U+fSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk+fSBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG5Qcm9taXNlLmFsbCA9IFFfYWxsO1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge1Byb21pc2V9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5Qcm9taXNlLnJhY2UgPSBRX3JhY2U7XG5cbi8qKlxuICogQ29lcmNlcyBhIHZhbHVlIHRvIGEgcHJvbWlzZS4gSWYgdGhlIHZhbHVlIGlzIGEgcHJvbWlzZSwgcGFzcyBpdCB0aHJvdWdoXG4gKiB1bmFsdGVyZWQuIElmIHRoZSB2YWx1ZSBoYXMgYSBgdGhlbmAgbWV0aG9kLCBpdCBpcyBwcmVzdW1lZCB0byBiZSBhIHByb21pc2VcbiAqIGJ1dCBub3Qgb25lIG9mIG91ciBvd24sIHNvIGl0IGlzIHRyZWF0ZWQgYXMgYSDigJx0aGVuYWJsZeKAnSBwcm9taXNlIGFuZCB0aGlzXG4gKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHN0YW5kcyBmb3IgaXQuIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0XG4gKiBoYXMgYWxyZWFkeSBiZWVuIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSBwcm9taXNlLCBvYmplY3Qgd2l0aCBhIHRoZW4gbWV0aG9kLCBvciBhIGZ1bGZpbGxtZW50IHZhbHVlXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhlIHNhbWUgcHJvbWlzZSBhcyBnaXZlbiwgb3IgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW5cbiAqIHZhbHVlXG4gKi9cblByb21pc2UucmVzb2x2ZSA9IFByb21pc2VfcmVzb2x2ZTtcbmZ1bmN0aW9uIFByb21pc2VfcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiBRKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGhhcyBiZWVuIHJlamVjdGVkIHdpdGggYSByZWFzb24sIHdoaWNoIHNob3VsZCBiZSBhblxuICogaW5zdGFuY2Ugb2YgYEVycm9yYC5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICogQHJldHVybnMge1Byb21pc2V9IHJlamVjdGlvblxuICovXG5Qcm9taXNlLnJlamVjdCA9IFFfcmVqZWN0O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHByb21pc2UuXG4gKi9cblEuaXNQcm9taXNlID0gUV9pc1Byb21pc2U7XG5mdW5jdGlvbiBRX2lzUHJvbWlzZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiAhIWhhbmRsZXJzLmdldChvYmplY3QpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIHRoZW4gbWV0aG9kLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNUaGVuYWJsZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHByb2R1Y2VzIGEgc25hcHNob3Qgb2YgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBwcm9taXNlLiAgVGhlXG4gKiBvYmplY3Qgd2lsbCBoYXZlIGEgYHN0YXRlYCBwcm9wZXJ0eS4gSWYgdGhlIGBzdGF0ZWAgaXMgYFwicGVuZGluZ1wiYCwgdGhlcmVcbiAqIHdpbGwgYmUgbm8gZnVydGhlciBpbmZvcm1hdGlvbi4gSWYgdGhlIGBzdGF0ZWAgaXMgYFwiZnVsZmlsbGVkXCJgLCB0aGVyZSB3aWxsXG4gKiBiZSBhIGB2YWx1ZWAgcHJvcGVydHkuIElmIHRoZSBzdGF0ZSBpcyBgXCJyZWplY3RlZFwiYCB0aGVyZSB3aWxsIGJlIGEgYHJlYXNvbmBcbiAqIHByb3BlcnR5LiAgSWYgdGhlIHByb21pc2Ugd2FzIGNvbnN0cnVjdGVkIGZyb20gYSDigJx0aGVuYWJsZeKAnSBhbmQgYHRoZW5gIG5vclxuICogYW55IG90aGVyIG1ldGhvZCBoYXMgYmVlbiBkaXNwYXRjaGVkIG9uIHRoZSBwcm9taXNlIGhhcyBiZWVuIGNhbGxlZCwgdGhlXG4gKiBzdGF0ZSB3aWxsIGJlIGBcInBlbmRpbmdcImAuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBub3QgYmUgdXBkYXRlZCBpZiB0aGVcbiAqIHN0YXRlIGNoYW5nZXMgYW5kIGNoYW5naW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHByb21pc2UuIEV2ZXJ5XG4gKiBjYWxsIHRvIGBpbnNwZWN0YCBwcm9kdWNlcyBhIHVuaXF1ZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7e3N0YXRlOiBzdHJpbmcsIHZhbHVlPywgcmVhc29uP319XG4gKi9cblByb21pc2UucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBQcm9taXNlX2luc3BlY3QoKSB7XG4gICAgLy8gdGhlIHNlY29uZCBsYXllciBjYXB0dXJlcyBvbmx5IHRoZSByZWxldmFudCBcInN0YXRlXCIgcHJvcGVydGllcyBvZiB0aGVcbiAgICAvLyBoYW5kbGVyIHRvIHByZXZlbnQgbGVha2luZyB0aGUgY2FwYWJpbGl0eSB0byBhY2Nlc3Mgb3IgYWx0ZXIgdGhlXG4gICAgLy8gaGFuZGxlci5cbiAgICByZXR1cm4gUV9nZXRIYW5kbGVyKHRoaXMpLmluc3BlY3QoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHByb21pc2UgaXMgd2FpdGluZyBmb3IgYSByZXN1bHQuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uIFByb21pc2VfaXNQZW5kaW5nKCkge1xuICAgIHJldHVybiBRX2dldEhhbmRsZXIodGhpcykuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcHJvbWlzZSBoYXMgZW5kZWQgaW4gYSByZXN1bHQgYW5kIGhhcyBhXG4gKiBmdWxmaWxsbWVudCB2YWx1ZS5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBQcm9taXNlX2lzRnVsZmlsbGVkKCkge1xuICAgIHJldHVybiBRX2dldEhhbmRsZXIodGhpcykuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBwcm9taXNlIGhhcyBlbmRlZCBwb29ybHkgYW5kIGhhcyBhIHJlYXNvbiBmb3JcbiAqIGl0cyByZWplY3Rpb24uXG4gKi9cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiBQcm9taXNlX2lzUmVqZWN0ZWQoKSB7XG4gICAgcmV0dXJuIFFfZ2V0SGFuZGxlcih0aGlzKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLnRvQmVQYXNzZWQgPSBmdW5jdGlvbiBQcm9taXNlX3RvQmVQYXNzZWQoKSB7XG4gICAgcmV0dXJuIFFfZ2V0SGFuZGxlcih0aGlzKS5zdGF0ZSA9PT0gXCJwYXNzZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gbWVyZWx5IGBcIltvYmplY3QgUHJvbWlzZV1cImBcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBQcm9taXNlX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm9taXNlLCB3YWl0cyBmb3IgdGhpcyBwcm9taXNlIHRvIGJlIHJlc29sdmVkLCBhbmQgaW5mb3Jtc1xuICogZWl0aGVyIHRoZSBmdWxsZmlsbGVkIG9yIHJlamVjdGVkIGhhbmRsZXIgb2YgdGhlIHJlc3VsdC4gV2hhdGV2ZXIgcmVzdWx0XG4gKiBjb21lcyBvZiB0aGUgZnVsZmlsbGVkIG9yIHJlamVjdGVkIGhhbmRsZXIsIGEgdmFsdWUgcmV0dXJuZWQsIGEgcHJvbWlzZVxuICogcmV0dXJuZWQsIG9yIGFuIGVycm9yIHRocm93biwgYmVjb21lcyB0aGUgcmVzb2x1dGlvbiBmb3IgdGhlIHByb21pc2VcbiAqIHJldHVybmVkIGJ5IGB0aGVuYC5cbiAqXG4gKiBAcGFyYW0gZnVsZmlsbGVkXG4gKiBAcGFyYW0gcmVqZWN0ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgdGhlIHJlc3VsdCBvZiBgZnVsZmlsbGVkYCBvciBgcmVqZWN0ZWRgLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gUHJvbWlzZV90aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG5cbiAgICB2YXIgX2Z1bGZpbGxlZDtcbiAgICBpZiAodHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIF9mdWxmaWxsZWQgPSBmdW5jdGlvbiBQcm9taXNlX3RoZW5fZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZnVsZmlsbGVkLmNhbGwodm9pZCAwLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9mdWxmaWxsZWQgPSBkZWZlcnJlZC5yZXNvbHZlO1xuICAgIH1cblxuICAgIHZhciBfcmVqZWN0ZWQ7XG4gICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIF9yZWplY3RlZCA9IGZ1bmN0aW9uIFByb21pc2VfdGhlbl9yZWplY3RlZChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlamVjdGVkLmNhbGwodm9pZCAwLCBlcnJvcikpO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZWplY3RlZCA9IGRlZmVycmVkLnJlamVjdDtcbiAgICB9XG5cbiAgICB0aGlzLmRvbmUoX2Z1bGZpbGxlZCwgX3JlamVjdGVkKTtcblxuICAgIGlmIChtcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciB1cGRhdGVFc3RpbWF0ZSA9IGZ1bmN0aW9uIFByb21pc2VfdGhlbl91cGRhdGVFc3RpbWF0ZSgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnNldEVzdGltYXRlKHNlbGYuZ2V0RXN0aW1hdGUoKSArIG1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYnNlcnZlRXN0aW1hdGUodXBkYXRlRXN0aW1hdGUpO1xuICAgICAgICB1cGRhdGVFc3RpbWF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0gZnVsZmlsbGVkXG4gKiBAcGFyYW0gcmVqZWN0ZWRcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIFByb21pc2VfZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG4gICAgYXNhcChmdW5jdGlvbiBQcm9taXNlX2RvbmVfdGFzaygpIHtcbiAgICAgICAgdmFyIF9mdWxmaWxsZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfZnVsZmlsbGVkID0gZnVuY3Rpb24gUHJvbWlzZV9kb25lX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkLmNhbGwodm9pZCAwLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byByZXRocm93IGlzIHN0aWxsIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBfZnVsZmlsbGVkIGlzIG5vdCBjYWxsZWQgaW4gdGhlIHNhbWUgZXZlbnQgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhYm92ZSBndWFyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIChRLm9uZXJyb3IgfHwgUHJvbWlzZV9yZXRocm93KShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZnVsZmlsbGVkID0gZnVuY3Rpb24gUHJvbWlzZV9kb25lX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWQuY2FsbCh2b2lkIDAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9yZWplY3RlZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiICYmIFEub25lcnJvcikge1xuICAgICAgICAgICAgX3JlamVjdGVkID0gZnVuY3Rpb24gUHJvbWlzZV9kb25lX3JlamVjdGVkKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHNlbGYpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkLmNhbGwodm9pZCAwLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobmV3RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKFEub25lcnJvciB8fCBQcm9taXNlX3JldGhyb3cpKG5ld0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBfcmVqZWN0ZWQgPSBmdW5jdGlvbiBQcm9taXNlX2RvbmVfcmVqZWN0ZWQoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgc2VsZik7XG4gICAgICAgICAgICAgICAgcmVqZWN0ZWQuY2FsbCh2b2lkIDAsIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVqZWN0ZWQgPSBRLm9uZXJyb3IgfHwgUHJvbWlzZV9yZXRocm93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgICAgICBfcmVqZWN0ZWQgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKF9yZWplY3RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBRX2dldEhhbmRsZXIoc2VsZikuZGlzcGF0Y2goX2Z1bGZpbGxlZCwgXCJ0aGVuXCIsIFtfcmVqZWN0ZWRdKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIFByb21pc2VfcmV0aHJvdyhlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIFRPRE9cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiBQcm9taXNlX3RoZW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgLy8gV3JhcHBpbmcgYWhlYWQgb2YgdGltZSB0byBmb3Jlc3RhbGwgbXVsdGlwbGUgd3JhcHBlcnMuXG4gICAgdmFsdWUgPSBRKHZhbHVlKTtcbiAgICAvLyBVc2luZyBhbGwgaXMgbmVjZXNzYXJ5IHRvIGFnZ3JlZ2F0ZSB0aGUgZXN0aW1hdGVkIHRpbWUgdG8gY29tcGxldGlvbi5cbiAgICByZXR1cm4gUV9hbGwoW3RoaXMsIHZhbHVlXSkudGhlbihmdW5jdGlvbiBQcm9taXNlX3RoZW5SZXNvbHZlX3Jlc29sdmVkKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgbnVsbCwgMCk7XG4gICAgLy8gMDogZG9lcyBub3QgY29udHJpYnV0ZSBzaWduaWZpY2FudGx5IHRvIHRoZSBlc3RpbWF0ZWQgdGltZSB0b1xuICAgIC8vIGNvbXBsZXRpb24uXG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlamVjdCA9IGZ1bmN0aW9uIFByb21pc2VfdGhlblJlamVjdChlcnJvcikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gUHJvbWlzZV90aGVuUmVqZWN0X3Jlc29sdmVkKCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9LCBudWxsLCAwKTtcbiAgICAvLyAwOiBkb2VzIG5vdCBjb250cmlidXRlIHNpZ25pZmljYW50bHkgdG8gdGhlIGVzdGltYXRlZCB0aW1lIHRvXG4gICAgLy8gY29tcGxldGlvbi5cbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiBQcm9taXNlX2FsbCgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFFfYWxsKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiBQcm9taXNlX2FsbFNldHRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRX2FsbFNldHRsZWQpO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gUHJvbWlzZV9jYXRjaChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIFByb21pc2VfZmluYWxseShjYWxsYmFjaywgbXMpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKCkudGhlbihmdW5jdGlvbiBQcm9taXNlX2ZpbmFsbHlfZnVsZmlsbGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoKS50aGVuKGZ1bmN0aW9uIFByb21pc2VfZmluYWxseV9yZWplY3RlZCgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSwgbXMpO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLm9ic2VydmVFc3RpbWF0ZSA9IGZ1bmN0aW9uIFByb21pc2Vfb2JzZXJ2ZUVzdGltYXRlKGVtaXQpIHtcbiAgICB0aGlzLnJhd0Rpc3BhdGNoKG51bGwsIFwiZXN0aW1hdGVcIiwgW2VtaXRdKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIFByb21pc2VfZ2V0RXN0aW1hdGUoKSB7XG4gICAgcmV0dXJuIFFfZ2V0SGFuZGxlcih0aGlzKS5lc3RpbWF0ZTtcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIFByb21pc2VfZGlzcGF0Y2gob3AsIGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRoaXMucmF3RGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKi9cblByb21pc2UucHJvdG90eXBlLnJhd0Rpc3BhdGNoID0gZnVuY3Rpb24gUHJvbWlzZV9yYXdEaXNwYXRjaChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBhc2FwKGZ1bmN0aW9uIFByb21pc2VfZGlzcGF0Y2hfdGFzaygpIHtcbiAgICAgICAgUV9nZXRIYW5kbGVyKHNlbGYpLmRpc3BhdGNoKHJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBQcm9taXNlX2dldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW25hbWVdKTtcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiBQcm9taXNlX2ludm9rZShuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiaW52b2tlXCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBQcm9taXNlX2FwcGx5KHRoaXNwLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJjYWxsXCIsIFthcmdzLCB0aGlzcF0pO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiBQcm9taXNlX2NhbGwodGhpc3AgLyosIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJjYWxsXCIsIFthcmdzLCB0aGlzcF0pO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBQcm9taXNlX2JpbmQodGhpc3AgLyosIC4uLmFyZ3MqLykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShNYXRoLm1heCgwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSkpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBQcm9taXNlX2JpbmRfYm91bmQoLyouLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJnc1tib3VuZEFyZ3MubGVuZ3RoXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZGlzcGF0Y2goXCJjYWxsXCIsIFtib3VuZEFyZ3MsIHRoaXNwXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gUHJvbWlzZV9rZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIFByb21pc2VfaXRlcmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIml0ZXJhdGVcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIFByb21pc2Vfc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiBQcm9taXNlX3NwcmVhZF9mdWxmaWxsZWQoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCwgbXMpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtTdHJpbmd9IGN1c3RvbSBlcnJvciBtZXNzYWdlIChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIFByb21zaWVfdGltZW91dChtcywgbWVzc2FnZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gUHJvbWlzZV90aW1lb3V0X3Rhc2soKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIikpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiBQcm9taXNlX3RpbWVvdXRfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiBQcm9taXNlX3RpbWVvdXRfcmVqZWN0ZWQoZXJyb3IpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIFByb21pc2VfZGVsYXkobXMpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIFByb21pc2VfZGVsYXlfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGRlZmVycmVkLnNldEVzdGltYXRlKERhdGUubm93KCkgKyBtcyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gUHJvbWlzZV9kZWxheV90YXNrKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIG1zKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSwgbnVsbCwgbXMpO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cblByb21pc2UucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbiBQcm9taXNlX3B1bGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwdWxsXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzID0gZnVuY3Rpb24gUHJvbWlzZV9wYXNzKCkge1xuICAgIGlmICghdGhpcy50b0JlUGFzc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKG5ldyBQYXNzZWQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblxuLy8gVGh1cyBiZWdpbnMgdGhlIHBvcnRpb24gZGVkaWNhdGVkIHRvIHRoZSBkZWZlcnJlZFxuXG52YXIgcHJvbWlzZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBEZWZlcnJlZChwcm9taXNlKSB7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAvLyBBIGRlZmVycmVkIGhhcyBhbiBpbnRyaW5zaWMgcHJvbWlzZSwgZGVub3RlZCBieSBpdHMgaGlkZGVuIGhhbmRsZXJcbiAgICAvLyBwcm9wZXJ0eS4gIFRoZSBwcm9taXNlIHByb3BlcnR5IG9mIHRoZSBkZWZlcnJlZCBtYXkgYmUgYXNzaWduZWQgdG8gYVxuICAgIC8vIGRpZmZlcmVudCBwcm9taXNlIChhcyBpdCBpcyBpbiBhIFF1ZXVlKSwgYnV0IHRoZSBpbnRyaW5zaWMgcHJvbWlzZSBkb2VzXG4gICAgLy8gbm90IGNoYW5nZS5cbiAgICBwcm9taXNlcy5zZXQodGhpcywgcHJvbWlzZSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXNvbHZlID0gdGhpcy5yZXNvbHZlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlLmNhbGwoc2VsZiwgdmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHJlamVjdCA9IHRoaXMucmVqZWN0O1xuICAgIHRoaXMucmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRPRE9cbiAqL1xuRGVmZXJyZWQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiBEZWZlcnJlZF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBRX2dldEhhbmRsZXIocHJvbWlzZXMuZ2V0KHRoaXMpKTtcbiAgICBpZiAoIWhhbmRsZXIubWVzc2FnZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVyLmJlY29tZShRKHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIFRPRE9cbiAqL1xuRGVmZXJyZWQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIERlZmVycmVkX3JlamVjdChyZWFzb24pIHtcbiAgICB2YXIgaGFuZGxlciA9IFFfZ2V0SGFuZGxlcihwcm9taXNlcy5nZXQodGhpcykpO1xuICAgIGlmICghaGFuZGxlci5tZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZXIuYmVjb21lKFFfcmVqZWN0KHJlYXNvbikpO1xufTtcblxuLyoqXG4gKiBUT0RPXG4gKi9cbkRlZmVycmVkLnByb3RvdHlwZS5zZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIERlZmVycmVkX3NldEVzdGltYXRlKGVzdGltYXRlKSB7XG4gICAgZXN0aW1hdGUgPSArZXN0aW1hdGU7XG4gICAgaWYgKGVzdGltYXRlICE9PSBlc3RpbWF0ZSkge1xuICAgICAgICBlc3RpbWF0ZSA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoZXN0aW1hdGUgPCAxZTEyICYmIGVzdGltYXRlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXN0aW1hdGUgdmFsdWVzIHNob3VsZCBiZSBhIG51bWJlciBvZiBtaWxpc2Vjb25kcyBpbiB0aGUgZnV0dXJlXCIpO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlciA9IFFfZ2V0SGFuZGxlcihwcm9taXNlcy5nZXQodGhpcykpO1xuICAgIC8vIFRPRE8gVGhlcmUgaXMgYSBiaXQgb2YgY2FwYWJpbGl0eSBsZWFrYWdlIGdvaW5nIG9uIGhlcmUuIFRoZSBEZWZlcnJlZFxuICAgIC8vIHNob3VsZCBvbmx5IGJlIGFibGUgdG8gc2V0IHRoZSBlc3RpbWF0ZSBmb3IgaXRzIG9yaWdpbmFsXG4gICAgLy8gUGVuZGluZywgbm90IGZvciBhbnkgaGFuZGxlciB0aGF0IHByb21pc2Ugc3Vic2VxdWVudGx5IGJlY2FtZS5cbiAgICBpZiAoaGFuZGxlci5zZXRFc3RpbWF0ZSkge1xuICAgICAgICBoYW5kbGVyLnNldEVzdGltYXRlKGVzdGltYXRlKTtcbiAgICB9XG59O1xuXG4vLyBUaHVzIGVuZHMgdGhlIHB1YmxpYyBpbnRlcmZhY2VcblxuLy8gVGh1cyBiZWdpbnMgdGhlIHBvcnRpb24gZGVkaWNhdGVkIHRvIGhhbmRsZXJzXG5cbmZ1bmN0aW9uIEZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmVzdGltYXRlID0gRGF0ZS5ub3coKTtcbn1cblxuRnVsZmlsbGVkLnByb3RvdHlwZS5zdGF0ZSA9IFwiZnVsZmlsbGVkXCI7XG5cbkZ1bGZpbGxlZC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIEZ1bGZpbGxlZF9pbnNwZWN0KCkge1xuICAgIHJldHVybiB7c3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB0aGlzLnZhbHVlfTtcbn07XG5cbkZ1bGZpbGxlZC5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBGdWxmaWxsZWRfZGlzcGF0Y2goXG4gICAgcmVzb2x2ZSwgb3AsIG9wZXJhbmRzXG4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChcbiAgICAgICAgb3AgPT09IFwidGhlblwiIHx8XG4gICAgICAgIG9wID09PSBcImdldFwiIHx8XG4gICAgICAgIG9wID09PSBcImNhbGxcIiB8fFxuICAgICAgICBvcCA9PT0gXCJpbnZva2VcIiB8fFxuICAgICAgICBvcCA9PT0gXCJrZXlzXCIgfHxcbiAgICAgICAgb3AgPT09IFwiaXRlcmF0ZVwiIHx8XG4gICAgICAgIG9wID09PSBcInB1bGxcIlxuICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpc1tvcF0uYXBwbHkodGhpcywgb3BlcmFuZHMpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFFfcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImVzdGltYXRlXCIpIHtcbiAgICAgICAgb3BlcmFuZHNbMF0uY2FsbCh2b2lkIDAsIHRoaXMuZXN0aW1hdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiRnVsZmlsbGVkIHByb21pc2VzIGRvIG5vdCBzdXBwb3J0IHRoZSBcIiArIG9wICsgXCIgb3BlcmF0b3JcIlxuICAgICAgICApO1xuICAgICAgICByZXN1bHQgPSBRX3JlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9XG59O1xuXG5GdWxmaWxsZWQucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiBGdWxmaWxsZWRfdGhlbigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbkZ1bGZpbGxlZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gRnVsZmlsbGVkX2dldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVbbmFtZV07XG59O1xuXG5GdWxmaWxsZWQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiBGdWxmaWxsZWRfY2FsbChhcmdzLCB0aGlzcCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxJbnZva2UodGhpcy52YWx1ZSwgYXJncywgdGhpc3ApO1xufTtcblxuRnVsZmlsbGVkLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiBGdWxmaWxsZWRfaW52b2tlKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsSW52b2tlKHRoaXMudmFsdWVbbmFtZV0sIGFyZ3MsIHRoaXMudmFsdWUpO1xufTtcblxuRnVsZmlsbGVkLnByb3RvdHlwZS5jYWxsSW52b2tlID0gZnVuY3Rpb24gRnVsZmlsbGVkX2NhbGxJbnZva2UoY2FsbGJhY2ssIGFyZ3MsIHRoaXNwKSB7XG4gICAgdmFyIHdhaXRUb0JlUGFzc2VkO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcmdzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoUV9pc1Byb21pc2UoYXJnc1tpbmRleF0pICYmIGFyZ3NbaW5kZXhdLnRvQmVQYXNzZWQoKSkge1xuICAgICAgICAgICAgd2FpdFRvQmVQYXNzZWQgPSB3YWl0VG9CZVBhc3NlZCB8fCBbXTtcbiAgICAgICAgICAgIHdhaXRUb0JlUGFzc2VkLnB1c2goYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3YWl0VG9CZVBhc3NlZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBRX2FsbCh3YWl0VG9CZVBhc3NlZCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsSW52b2tlKGNhbGxiYWNrLCBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKFFfaXNQcm9taXNlKGFyZykgJiYgYXJnLnRvQmVQYXNzZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmluc3BlY3QoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB0aGlzcCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgfVxufTtcblxuRnVsZmlsbGVkLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gRnVsZmlsbGVkX2tleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWUpO1xufTtcblxuRnVsZmlsbGVkLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gRnVsZmlsbGVkX2l0ZXJhdGUoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdGUodGhpcy52YWx1ZSk7XG59O1xuXG5GdWxmaWxsZWQucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbiBGdWxmaWxsZWRfcHVsbCgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChPYmplY3QodGhpcy52YWx1ZSkgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSA/IFtdIDoge307XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdGhpcy52YWx1ZVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBRLnB1c2gocmVzdWx0KTtcbn07XG5cblxuZnVuY3Rpb24gUmVqZWN0ZWQocmVhc29uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lc3RpbWF0ZSA9IEluZmluaXR5O1xufVxuXG5SZWplY3RlZC5wcm90b3R5cGUuc3RhdGUgPSBcInJlamVjdGVkXCI7XG5cblJlamVjdGVkLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gUmVqZWN0ZWRfaW5zcGVjdCgpIHtcbiAgICByZXR1cm4ge3N0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogdGhpcy5yZWFzb259O1xufTtcblxuUmVqZWN0ZWQucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gUmVqZWN0ZWRfZGlzcGF0Y2goXG4gICAgcmVzb2x2ZSwgb3AsIG9wZXJhbmRzXG4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChvcCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aGVuKHJlc29sdmUsIG9wZXJhbmRzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxufTtcblxuUmVqZWN0ZWQucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiBSZWplY3RlZF90aGVuKFxuICAgIHJlc29sdmUsIHJlamVjdGVkXG4pIHtcbiAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCh0aGlzLnJlYXNvbikgOiB0aGlzO1xufTtcblxuXG5mdW5jdGlvbiBQZW5kaW5nKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIHRoaXMuZXN0aW1hdGUgPSBJbmZpbml0eTtcbn1cblxuUGVuZGluZy5wcm90b3R5cGUuc3RhdGUgPSBcInBlbmRpbmdcIjtcblxuUGVuZGluZy5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIFBlbmRpbmdfaW5zcGVjdCgpIHtcbiAgICByZXR1cm4ge3N0YXRlOiBcInBlbmRpbmdcIn07XG59O1xuXG5QZW5kaW5nLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIFBlbmRpbmdfZGlzcGF0Y2gocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKFtyZXNvbHZlLCBvcCwgb3BlcmFuZHNdKTtcbiAgICBpZiAob3AgPT09IFwiZXN0aW1hdGVcIikge1xuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9wZXJhbmRzWzBdKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBhc2FwKGZ1bmN0aW9uIFBlbmRpbmdfZGlzcGF0Y2hfdGFzaygpIHtcbiAgICAgICAgICAgIG9wZXJhbmRzWzBdLmNhbGwodm9pZCAwLCBzZWxmLmVzdGltYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuUGVuZGluZy5wcm90b3R5cGUuYmVjb21lID0gZnVuY3Rpb24gUGVuZGluZ19iZWNvbWUocHJvbWlzZSkge1xuICAgIHRoaXMuYmVjYW1lID0gdGhlVmljaW91c0N5Y2xlO1xuICAgIHZhciBoYW5kbGVyID0gUV9nZXRIYW5kbGVyKHByb21pc2UpO1xuICAgIHRoaXMuYmVjYW1lID0gaGFuZGxlcjtcblxuICAgIGhhbmRsZXJzLnNldChwcm9taXNlLCBoYW5kbGVyKTtcbiAgICB0aGlzLnByb21pc2UgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gUGVuZGluZ19iZWNvbWVfZWFjaE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvLyBtYWtlUSBkb2VzIG5vdCBoYXZlIHRoaXMgYXNhcCBjYWxsLCBzbyBpdCBtdXN0IGJlIHF1ZXVlaW5nIGV2ZW50c1xuICAgICAgICAvLyBkb3duc3RyZWFtLiBUT0RPIGxvb2sgYXQgbWFrZVEgdG8gYXNjZXJ0YWluXG4gICAgICAgIGFzYXAoZnVuY3Rpb24gUGVuZGluZ19iZWNvbWVfZWFjaE1lc3NhZ2VfdGFzaygpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gUV9nZXRIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgaGFuZGxlci5kaXNwYXRjaC5hcHBseShoYW5kbGVyLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lc3NhZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXJzID0gdm9pZCAwO1xufTtcblxuUGVuZGluZy5wcm90b3R5cGUuc2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBQZW5kaW5nX3NldEVzdGltYXRlKGVzdGltYXRlKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5lc3RpbWF0ZSA9IGVzdGltYXRlO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIFBlbmRpbmdfZWFjaE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBhc2FwKGZ1bmN0aW9uIFBlbmRpbmdfc2V0RXN0aW1hdGVfZWFjaE9ic2VydmVyX3Rhc2soKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbCh2b2lkIDAsIGVzdGltYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgIHRoaXMudGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICB0aGlzLmJlY2FtZSA9IG51bGw7XG4gICAgdGhpcy5lc3RpbWF0ZSA9IEluZmluaXR5O1xufVxuXG5UaGVuYWJsZS5wcm90b3R5cGUuc3RhdGUgPSBcInRoZW5hYmxlXCI7XG5cblRoZW5hYmxlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gVGhlbmFibGVfaW5zcGVjdCgpIHtcbiAgICByZXR1cm4ge3N0YXRlOiBcInBlbmRpbmdcIn07XG59O1xuXG5UaGVuYWJsZS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uIFRoZW5hYmxlX2Nhc3QoKSB7XG4gICAgaWYgKCF0aGlzLmJlY2FtZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICB2YXIgdGhlbmFibGUgPSB0aGlzLnRoZW5hYmxlO1xuICAgICAgICBhc2FwKGZ1bmN0aW9uIFRoZW5hYmxlX2Nhc3RfdGFzaygpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJlY2FtZSA9IFFfZ2V0SGFuZGxlcihkZWZlcnJlZC5wcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmVjYW1lO1xufTtcblxuVGhlbmFibGUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gVGhlbmFibGVfZGlzcGF0Y2gocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICB0aGlzLmNhc3QoKS5kaXNwYXRjaChyZXNvbHZlLCBvcCwgYXJncyk7XG59O1xuXG5cbmZ1bmN0aW9uIFBhc3NlZChwcm9taXNlKSB7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuUGFzc2VkLnByb3RvdHlwZS5zdGF0ZSA9IFwicGFzc2VkXCI7XG5cblBhc3NlZC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIFBhc3NlZF9pbnNwZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UuaW5zcGVjdCgpO1xufTtcblxuUGFzc2VkLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIFBhc3NlZF9kaXNwYXRjaChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UucmF3RGlzcGF0Y2gocmVzb2x2ZSwgb3AsIGFyZ3MpO1xufTtcblxuXG4vLyBUaHVzIGJlZ2lucyB0aGUgUSBOb2RlLmpzIGJyaWRnZVxuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5pbnZva2UgPSBmdW5jdGlvbiBRX25pbnZva2Uob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoTWF0aC5tYXgoMCwgYXJndW1lbnRzLmxlbmd0aCAtIDEpKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDI7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBhcmdzW2luZGV4IC0gMl0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBRLmRlZmVyKCk7XG4gICAgYXJnc1tpbmRleCAtIDJdID0gZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcImludm9rZVwiLCBbbmFtZSwgYXJnc10pLmNhdGNoKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gUHJvbWlzZV9uaW52b2tlKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBRLmRlZmVyKCk7XG4gICAgYXJnc1tpbmRleCAtIDFdID0gZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJpbnZva2VcIiwgW25hbWUsIGFyZ3NdKS5jYXRjaChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGUuanMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEuZGVub2RlaWZ5KEZTLnJlYWRGaWxlKShfX2ZpbGVuYW1lLCBcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiBRX2Rlbm9kZWlmeShjYWxsYmFjaywgcGF0dGVybikge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZW5vZGVpZmllZCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCArIDEpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgICAgICBhcmdzW2luZGV4XSA9IGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIocGF0dGVybik7XG4gICAgICAgIFEoY2FsbGJhY2spLmFwcGx5KHRoaXMsIGFyZ3MpLmNhdGNoKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcGFyYW0gdW5wYWNrIGB0cnVlYCBtZWFucyB0aGF0IHRoZSBOb2RlLmpzLXN0eWxlLWNhbGxiYWNrIGFjY2VwdHMgYVxuICogZml4ZWQgb3IgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGhhdCB0aGUgZGVmZXJyZWQgc2hvdWxkIGJlIHJlc29sdmVkXG4gKiB3aXRoIGFuIGFycmF5IG9mIHRoZXNlIHZhbHVlIGFyZ3VtZW50cywgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IgYXJndW1lbnQuXG4gKiBBbiBhcnJheSBvZiBuYW1lcyBtZWFucyB0aGF0IHRoZSBOb2RlLmpzLXN0eWxlLWNhbGxiYWNrIGFjY2VwdHMgYSBmaXhlZFxuICogbnVtYmVyIG9mIGFyZ3VtZW50cywgYW5kIHRoYXQgdGhlIHJlc29sdXRpb24gc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoXG4gKiBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIG5hbWVzIGFuZCByZXNwZWN0aXZlIHZhbHVlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuRGVmZXJyZWQucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAodW5wYWNrKSB7XG4gICAgdmFyIHJlc29sdmUgPSB0aGlzLnJlc29sdmU7XG4gICAgaWYgKHVucGFjayA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdmFyaWFkaWNOb2RlYmFja1RvUmVzb2x2ZXIoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoUV9yZWplY3QoZXJyb3IpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodW5wYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuYW1lZEFyZ3VtZW50Tm9kZWJhY2tUb1Jlc29sdmVyKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFFfcmVqZWN0KGVycm9yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB1bnBhY2subGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW3VucGFja1tpbmRleF1dID0gYXJndW1lbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBub2RlYmFja1RvUmVzb2x2ZXIoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFFfcmVqZWN0KGVycm9yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogVE9ET1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gUHJvbWlzZV9ub2RlaWZ5KG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMuZG9uZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgfSwgbm9kZWJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblxuLy8gREVQUkVDQVRFRFxuXG5RLm5leHRUaWNrID0gZGVwcmVjYXRlKGFzYXAsIFwibmV4dFRpY2tcIiwgXCJhc2FwIHBhY2thZ2VcIik7XG5cblEucmVzb2x2ZSA9IGRlcHJlY2F0ZShRLCBcInJlc29sdmVcIiwgXCJRXCIpO1xuXG5RLmZ1bGZpbGwgPSBkZXByZWNhdGUoUSwgXCJmdWxmaWxsXCIsIFwiUVwiKTtcblxuUS5pc1Byb21pc2VBbGlrZSA9IGRlcHJlY2F0ZShpc1RoZW5hYmxlLCBcImlzUHJvbWlzZUFsaWtlXCIsIFwiKG5vdCBzdXBwb3J0ZWQpXCIpO1xuXG5RLmZhaWwgPSBkZXByZWNhdGUoZnVuY3Rpb24gKHZhbHVlLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5jYXRjaChyZWplY3RlZCk7XG59LCBcIlEuZmFpbFwiLCBcIlEodmFsdWUpLmNhdGNoXCIpO1xuXG5RLmZpbiA9IGRlcHJlY2F0ZShmdW5jdGlvbiAodmFsdWUsIHJlZ2FyZGxlc3MpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuZmluYWxseShyZWdhcmRsZXNzKTtcbn0sIFwiUS5maW5cIiwgXCJRKHZhbHVlKS5maW5hbGx5XCIpO1xuXG5RLnByb2dyZXNzID0gZGVwcmVjYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn0sIFwiUS5wcm9ncmVzc1wiLCBcIm5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG5cblEudGhlblJlc29sdmUgPSBkZXByZWNhdGUoZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlc29sdmUodmFsdWUpO1xufSwgXCJ0aGVuUmVzb2x2ZVwiLCBcIlEodmFsdWUpLnRoZW5SZXNvbHZlXCIpO1xuXG5RLnRoZW5SZWplY3QgPSBkZXByZWNhdGUoZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHJlYXNvbik7XG59LCBcInRoZW5SZXNvbHZlXCIsIFwiUSh2YWx1ZSkudGhlblJlc29sdmVcIik7XG5cblEuaXNQZW5kaW5nID0gZGVwcmVjYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBRKHZhbHVlKS5pc1BlbmRpbmcoKTtcbn0sIFwiaXNQZW5kaW5nXCIsIFwiUSh2YWx1ZSkuaXNQZW5kaW5nXCIpO1xuXG5RLmlzRnVsZmlsbGVkID0gZGVwcmVjYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBRKHZhbHVlKS5pc0Z1bGZpbGxlZCgpO1xufSwgXCJpc0Z1bGZpbGxlZFwiLCBcIlEodmFsdWUpLmlzRnVsZmlsbGVkXCIpO1xuXG5RLmlzUmVqZWN0ZWQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLmlzUmVqZWN0ZWQoKTtcbn0sIFwiaXNSZWplY3RlZFwiLCBcIlEodmFsdWUpLmlzUmVqZWN0ZWRcIik7XG5cblEubWFzdGVyID0gZGVwcmVjYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn0sIFwibWFzdGVyXCIsIFwibm8gbG9uZ2VyIG5lY2Vzc2FyeVwiKTtcblxuUS5tYWtlUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWtlUHJvbWlzZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xufTtcblxuUS5kaXNwYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAodmFsdWUsIG9wLCBvcGVyYW5kcykge1xuICAgIHJldHVybiBRKHZhbHVlKS5kaXNwYXRjaChvcCwgb3BlcmFuZHMpO1xufSwgXCJkaXNwYXRjaFwiLCBcIlEodmFsdWUpLmRpc3BhdGNoXCIpO1xuXG5RLmdldCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAob2JqZWN0LCBuYW1lKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5nZXQobmFtZSk7XG59LCBcImdldFwiLCBcIlEodmFsdWUpLmdldFwiKTtcblxuUS5rZXlzID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmtleXMoKTtcbn0sIFwia2V5c1wiLCBcIlEodmFsdWUpLmtleXNcIik7XG5cblEucG9zdCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5wb3N0KG5hbWUsIGFyZ3MpO1xufSwgXCJwb3N0XCIsIFwiUSh2YWx1ZSkuaW52b2tlIChzcHJlYWQgYXJndW1lbnRzKVwiKTtcblxuUS5tYXBwbHkgPSBkZXByZWNhdGUoZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkucG9zdChuYW1lLCBhcmdzKTtcbn0sIFwicG9zdFwiLCBcIlEodmFsdWUpLmludm9rZSAoc3ByZWFkIGFyZ3VtZW50cylcIik7XG5cblEuc2VuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAob2JqZWN0LCBuYW1lKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5wb3N0KG5hbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xufSwgXCJzZW5kXCIsIFwiUSh2YWx1ZSkuaW52b2tlXCIpO1xuXG5RLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRLnNldCBubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xufTtcblxuUS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUS5kZWxldGUgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbn07XG5cblEubmVhcmVyID0gZGVwcmVjYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChRX2lzUHJvbWlzZSh2YWx1ZSkgJiYgdmFsdWUuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdCgpLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59LCBcIm5lYXJlclwiLCBcImluc3BlY3QoKS52YWx1ZSAoK251YW5jZXMpXCIpO1xuXG5RLmZhcHBseSA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykuZGlzcGF0Y2goXCJjYWxsXCIsIFthcmdzXSk7XG59LCBcImZhcHBseVwiLCBcIlEoY2FsbGJhY2spLmFwcGx5KHRoaXNwLCBhcmdzKVwiKTtcblxuUS5mY2FsbCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoY2FsbGJhY2sgLyosIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5kaXNwYXRjaChcImNhbGxcIiwgW0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSldKTtcbn0sIFwiZmNhbGxcIiwgXCJRKGNhbGxiYWNrKS5jYWxsKHRoaXNwLCAuLi5hcmdzKVwiKTtcblxuUS5mYmluZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiY2FsbFwiLCBbXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfTtcbn0sIFwiZmJpbmRcIiwgXCJiaW5kIHdpdGggdGhpc3BcIik7XG5cblEucHJvbWlzZSA9IGRlcHJlY2F0ZShQcm9taXNlLCBcInByb21pc2VcIiwgXCJQcm9taXNlXCIpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImNhbGxcIiwgW2FyZ3NdKTtcbn0sIFwiZmFwcGx5XCIsIFwiYXBwbHkgd2l0aCB0aGlzcFwiKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBkZXByZWNhdGUoZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJjYWxsXCIsIFtBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXSk7XG59LCBcImZjYWxsXCIsIFwidHJ5IG9yIGNhbGwgd2l0aCB0aGlzcFwiKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5jYXRjaChyZWplY3RlZCk7XG59LCBcImZhaWxcIiwgXCJjYXRjaFwiKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChyZWdhcmRsZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxseShyZWdhcmRsZXNzKTtcbn0sIFwiZmluXCIsIFwiZmluYWxseVwiKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2Ugc2V0IG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBkZWxldGUgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbn07XG5cbkRlZmVycmVkLnByb3RvdHlwZS5ub3RpZnkgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xufSwgXCJub3RpZnlcIiwgXCJubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG59LCBcInByb2dyZXNzXCIsIFwibm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcblxuLy8gYWx0ZXJuYXRpdmUgcHJvcG9zZWQgYnkgUmVkc2FuZHJvLCBkcm9wcGVkIGluIGZhdm9yIG9mIHBvc3QgdG8gc3RyZWFtbGluZVxuLy8gdGhlIGludGVyZmFjZVxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJpbnZva2VcIiwgW25hbWUsIGFyZ3NdKTtcbn0sIFwibWFwcGx5XCIsIFwiaW52b2tlXCIpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFEuZmJpbmQuYXBwbHkoUSwgW3ZvaWQgMF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn0sIFwiZmJpbmRcIiwgXCJiaW5kKHRoaXNwLCAuLi5hcmdzKVwiKTtcblxuLy8gYWx0ZXJuYXRpdmUgcHJvcG9zZWQgYnkgTWFyayBNaWxsZXIsIGRyb3BwZWQgaW4gZmF2b3Igb2YgaW52b2tlXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImludm9rZVwiLCBbbmFtZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKV0pO1xufSwgXCJzZW5kXCIsIFwiaW52b2tlXCIpO1xuXG4vLyBhbHRlcm5hdGl2ZSBwcm9wb3NlZCBieSBSZWRzYW5kcm8sIGRyb3BwZWQgaW4gZmF2b3Igb2YgaW52b2tlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJpbnZva2VcIiwgW25hbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSldKTtcbn0sIFwibWNhbGxcIiwgXCJpbnZva2VcIik7XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBkZXByZWNhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufSwgXCJwYXNzQnlDb3B5XCIsIFwiUS5wYXNzQnlDb3B5XCIpO1xuXG4vLyBEZXByZWNhdGVkIE5vZGUuanMgYnJpZGdlIHByb21pc2UgbWV0aG9kc1xuXG5RLm5mYXBwbHkgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKGNhbGxiYWNrKS5hcHBseSh0aGlzLCBub2RlQXJncykuY2F0Y2goZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn0sIFwibmZhcHBseVwiKTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBRLm5mYXBwbHkodGhpcywgYXJncyk7XG59LCBcIm5mYXBwbHlcIik7XG5cblEubmZjYWxsID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUS5uZmFwcGx5KGNhbGxiYWNrLCBhcmdzKTtcbn0sIFwibmZjYWxsXCIpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIFEubmZhcHBseSh0aGlzLCBhcmdzKTtcbn0sIFwibmZjYWxsXCIpO1xuXG5RLm5mYmluZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmFwcGx5KHRoaXMsIG5vZGVBcmdzKS5jYXRjaChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufSwgXCJuZmJpbmRcIiwgXCJkZW5vZGVpZnkgKHdpdGggY2F2ZWF0cylcIik7XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gUS5uZmJpbmQodGhpcywgYXJncyk7XG59LCBcIm5mYmluZFwiLCBcImRlbm9kZWlmeSAod2l0aCBjYXZlYXRzKVwiKTtcblxuUS5uYmluZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5hcHBseSh0aGlzLCBub2RlQXJncykuY2F0Y2goZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn0sIFwibmJpbmRcIiwgXCJkZW5vZGVpZnkgKHdpdGggY2F2ZWF0cylcIik7XG5cblEubnBvc3QgPSBkZXByZWNhdGUoZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbm9kZUFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBRLmRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcImludm9rZVwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5jYXRjaChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufSwgXCJucG9zdFwiLCBcIm5pbnZva2UgKHdpdGggc3ByZWFkIGFyZ3VtZW50cylcIik7XG5cblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEubnBvc3QodGhpcywgbmFtZSwgYXJncyk7XG59LCBcIm5wb3N0XCIsIFwiUS5uaW52b2tlICh3aXRoIGNhdmVhdHMpXCIpO1xuXG5RLm5tYXBwbHkgPSBkZXByZWNhdGUoUS5ubWFwcGx5LCBcIm5tYXBwbHlcIiwgXCJxL25vZGUgbm1hcHBseVwiKTtcblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSBkZXByZWNhdGUoUHJvbWlzZS5wcm90b3R5cGUubnBvc3QsIFwibm1hcHBseVwiLCBcIlEubm1hcHBseVwiKTtcblxuUS5uc2VuZCA9IGRlcHJlY2F0ZShRLm5pbnZva2UsIFwibnNlbmRcIiwgXCJxL25vZGUgbmludm9rZVwiKTtcblEubm1jYWxsID0gZGVwcmVjYXRlKFEubmludm9rZSwgXCJubWNhbGxcIiwgXCJxL25vZGUgbmludm9rZVwiKTtcblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gZGVwcmVjYXRlKFByb21pc2UucHJvdG90eXBlLm5pbnZva2UsIFwibnNlbmRcIiwgXCJxL25vZGUgbmludm9rZVwiKTtcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IGRlcHJlY2F0ZShQcm9taXNlLnByb3RvdHlwZS5uaW52b2tlLCBcIm5tY2FsbFwiLCBcInEvbm9kZSBuaW52b2tlXCIpO1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxuIl0sIm5hbWVzIjpbImhhc1N0YWNrcyIsIkVycm9yIiwiZSIsInN0YWNrIiwicVN0YXJ0aW5nTGluZSIsImNhcHR1cmVMaW5lIiwicUZpbGVOYW1lIiwiV2Vha01hcCIsInJlcXVpcmUiLCJpdGVyYXRlIiwiYXNhcCIsImlzT2JqZWN0IiwidmFsdWUiLCJPYmplY3QiLCJTVEFDS19KVU1QX1NFUEFSQVRPUiIsIm1ha2VTdGFja1RyYWNlTG9uZyIsImVycm9yIiwicHJvbWlzZSIsImluZGV4T2YiLCJzdGFja3MiLCJwIiwiaGFuZGxlcnMiLCJnZXQiLCJiZWNhbWUiLCJ1bnNoaWZ0IiwiY29uY2F0ZWRTdGFja3MiLCJqb2luIiwiZmlsdGVyU3RhY2tTdHJpbmciLCJzdGFja1N0cmluZyIsIlEiLCJpc0ludHJvc3BlY3RpdmUiLCJsaW5lcyIsInNwbGl0IiwiZGVzaXJlZExpbmVzIiwiaSIsImxlbmd0aCIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInB1c2giLCJzdGFja0xpbmUiLCJnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIiLCJhdHRlbXB0MSIsImV4ZWMiLCJOdW1iZXIiLCJhdHRlbXB0MiIsImF0dGVtcHQzIiwiZmlsZU5hbWVBbmRMaW5lTnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwicUVuZGluZ0xpbmUiLCJmaXJzdExpbmUiLCJkZXByZWNhdGUiLCJjYWxsYmFjayIsIm5hbWUiLCJhbHRlcm5hdGl2ZSIsIlFfZGVwcmVjYXRlIiwiY29uc29sZSIsIndhcm4iLCJhcHBseSIsImFyZ3VtZW50cyIsIlFfZ2V0SGFuZGxlciIsImhhbmRsZXIiLCJmb2xsb3ciLCJzZXQiLCJ0aGVWaWNpb3VzQ3ljbGVFcnJvciIsInRoZVZpY2lvdXNDeWNsZVJlamVjdGlvbiIsIlFfcmVqZWN0IiwidGhlVmljaW91c0N5Y2xlIiwidGhlbmFibGVzIiwibW9kdWxlIiwiZXhwb3J0cyIsIlFfaXNQcm9taXNlIiwiaXNUaGVuYWJsZSIsImhhcyIsIlByb21pc2UiLCJUaGVuYWJsZSIsIkZ1bGZpbGxlZCIsImxvbmdTdGFja1N1cHBvcnQiLCJyZWplY3QiLCJSZWplY3RlZCIsImRlZmVyIiwiUGVuZGluZyIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJzdWJzdHJpbmciLCJ3aGVuIiwiUV93aGVuIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJtcyIsInRoZW4iLCJhbGwiLCJRX2FsbCIsInF1ZXN0aW9ucyIsImNvdW50RG93biIsImFuc3dlcnMiLCJBcnJheSIsImVzdGltYXRlcyIsImVzdGltYXRlIiwiSW5maW5pdHkiLCJzZXRFc3RpbWF0ZSIsInByb3RvdHlwZSIsImZvckVhY2giLCJjYWxsIiwiUV9hbGxfZWFjaCIsImluZGV4Iiwic3RhdGUiLCJRX2FsbF9lYWNoRnVsZmlsbGVkIiwicmVzb2x2ZSIsIm9ic2VydmVFc3RpbWF0ZSIsIlFfYWxsX2VhY2hFc3RpbWF0ZSIsIm5ld0VzdGltYXRlIiwib2xkRXN0aW1hdGUiLCJjb21wdXRlRXN0aW1hdGUiLCJhbGxTZXR0bGVkIiwiUV9hbGxTZXR0bGVkIiwibWFwIiwiUV9hbGxTZXR0bGVkX2VhY2giLCJyZWdhcmRsZXNzIiwiaW5zcGVjdCIsImRlbGF5IiwiUV9kZWxheSIsIm9iamVjdCIsInRpbWVvdXQiLCJRX3RpbWVvdXQiLCJtZXNzYWdlIiwic3ByZWFkIiwiUV9zcHJlYWQiLCJRX2pvaW4iLCJ4IiwieSIsIlFfam9pbmVkIiwicmFjZSIsIlFfcmFjZSIsImFuc3dlclBzIiwiYW5zd2VyUCIsInRyeSIsIlFfdHJ5IiwiZGlzcGF0Y2giLCJmdW5jdGlvbiIsIlByb21pc2VfZnVuY3Rpb24iLCJ3cmFwcGVkIiwicHJvbWlzZUZ1bmN0aW9uV3JhcHBlciIsImFyZ3MiLCJwcm9taXNlZCIsIlFfcHJvbWlzZWQiLCJwcm9taXNlZE1ldGhvZCIsIlFfcHJvbWlzZWRfc3ByZWFkIiwic2VsZiIsInBhc3NCeUNvcHkiLCJwYXNzQnlDb3BpZXMiLCJpc1BvcnRhYmxlIiwiYXN5bmMiLCJRX2FzeW5jIiwibWFrZUdlbmVyYXRvciIsInNwYXduIiwiY29udGludWVyIiwidmVyYiIsImFyZyIsIml0ZXJhdGlvbiIsImdlbmVyYXRvciIsImV4Y2VwdGlvbiIsImRvbmUiLCJlcnJiYWNrIiwiYmluZCIsIlFfc3Bhd24iLCJzZXR1cCIsIlByb21pc2VfcmVzb2x2ZSIsImlzUHJvbWlzZSIsIlByb21pc2VfaW5zcGVjdCIsImlzUGVuZGluZyIsIlByb21pc2VfaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJQcm9taXNlX2lzRnVsZmlsbGVkIiwiaXNSZWplY3RlZCIsIlByb21pc2VfaXNSZWplY3RlZCIsInRvQmVQYXNzZWQiLCJQcm9taXNlX3RvQmVQYXNzZWQiLCJ0b1N0cmluZyIsIlByb21pc2VfdG9TdHJpbmciLCJQcm9taXNlX3RoZW4iLCJfZnVsZmlsbGVkIiwiUHJvbWlzZV90aGVuX2Z1bGZpbGxlZCIsIl9yZWplY3RlZCIsIlByb21pc2VfdGhlbl9yZWplY3RlZCIsIm5ld0Vycm9yIiwidXBkYXRlRXN0aW1hdGUiLCJQcm9taXNlX3RoZW5fdXBkYXRlRXN0aW1hdGUiLCJnZXRFc3RpbWF0ZSIsIlByb21pc2VfZG9uZSIsIlByb21pc2VfZG9uZV90YXNrIiwib25lcnJvciIsIlByb21pc2VfZG9uZV9mdWxmaWxsZWQiLCJQcm9taXNlX3JldGhyb3ciLCJQcm9taXNlX2RvbmVfcmVqZWN0ZWQiLCJwcm9jZXNzIiwiZG9tYWluIiwidGhlblJlc29sdmUiLCJQcm9taXNlX3RoZW5SZXNvbHZlIiwiUHJvbWlzZV90aGVuUmVzb2x2ZV9yZXNvbHZlZCIsInRoZW5SZWplY3QiLCJQcm9taXNlX3RoZW5SZWplY3QiLCJQcm9taXNlX3RoZW5SZWplY3RfcmVzb2x2ZWQiLCJQcm9taXNlX2FsbCIsIlByb21pc2VfYWxsU2V0dGxlZCIsImNhdGNoIiwiUHJvbWlzZV9jYXRjaCIsImZpbmFsbHkiLCJQcm9taXNlX2ZpbmFsbHkiLCJQcm9taXNlX2ZpbmFsbHlfZnVsZmlsbGVkIiwicmVhc29uIiwiUHJvbWlzZV9maW5hbGx5X3JlamVjdGVkIiwiUHJvbWlzZV9vYnNlcnZlRXN0aW1hdGUiLCJlbWl0IiwicmF3RGlzcGF0Y2giLCJQcm9taXNlX2dldEVzdGltYXRlIiwiUHJvbWlzZV9kaXNwYXRjaCIsIm9wIiwiUHJvbWlzZV9yYXdEaXNwYXRjaCIsIlByb21pc2VfZGlzcGF0Y2hfdGFzayIsIlByb21pc2VfZ2V0IiwiaW52b2tlIiwiUHJvbWlzZV9pbnZva2UiLCJQcm9taXNlX2FwcGx5IiwidGhpc3AiLCJQcm9taXNlX2NhbGwiLCJNYXRoIiwibWF4IiwiUHJvbWlzZV9iaW5kIiwiUHJvbWlzZV9iaW5kX2JvdW5kIiwiYm91bmRBcmdzIiwic2xpY2UiLCJrZXlzIiwiUHJvbWlzZV9rZXlzIiwiUHJvbWlzZV9pdGVyYXRlIiwiUHJvbWlzZV9zcHJlYWQiLCJQcm9taXNlX3NwcmVhZF9mdWxmaWxsZWQiLCJhcnJheSIsIlByb21zaWVfdGltZW91dCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJQcm9taXNlX3RpbWVvdXRfdGFzayIsIlByb21pc2VfdGltZW91dF9mdWxmaWxsZWQiLCJjbGVhclRpbWVvdXQiLCJQcm9taXNlX3RpbWVvdXRfcmVqZWN0ZWQiLCJQcm9taXNlX2RlbGF5IiwiUHJvbWlzZV9kZWxheV9mdWxmaWxsZWQiLCJEYXRlIiwibm93IiwiUHJvbWlzZV9kZWxheV90YXNrIiwicHVsbCIsIlByb21pc2VfcHVsbCIsInBhc3MiLCJQcm9taXNlX3Bhc3MiLCJQYXNzZWQiLCJwcm9taXNlcyIsIkRlZmVycmVkX3Jlc29sdmUiLCJtZXNzYWdlcyIsImJlY29tZSIsIkRlZmVycmVkX3JlamVjdCIsIkRlZmVycmVkX3NldEVzdGltYXRlIiwiRnVsZmlsbGVkX2luc3BlY3QiLCJGdWxmaWxsZWRfZGlzcGF0Y2giLCJvcGVyYW5kcyIsInJlc3VsdCIsIkZ1bGZpbGxlZF90aGVuIiwiRnVsZmlsbGVkX2dldCIsIkZ1bGZpbGxlZF9jYWxsIiwiY2FsbEludm9rZSIsIkZ1bGZpbGxlZF9pbnZva2UiLCJGdWxmaWxsZWRfY2FsbEludm9rZSIsIndhaXRUb0JlUGFzc2VkIiwiRnVsZmlsbGVkX2tleXMiLCJGdWxmaWxsZWRfaXRlcmF0ZSIsIkZ1bGZpbGxlZF9wdWxsIiwiaXNBcnJheSIsIlJlamVjdGVkX2luc3BlY3QiLCJSZWplY3RlZF9kaXNwYXRjaCIsIlJlamVjdGVkX3RoZW4iLCJvYnNlcnZlcnMiLCJQZW5kaW5nX2luc3BlY3QiLCJQZW5kaW5nX2Rpc3BhdGNoIiwiUGVuZGluZ19kaXNwYXRjaF90YXNrIiwiUGVuZGluZ19iZWNvbWUiLCJQZW5kaW5nX2JlY29tZV9lYWNoTWVzc2FnZSIsIlBlbmRpbmdfYmVjb21lX2VhY2hNZXNzYWdlX3Rhc2siLCJQZW5kaW5nX3NldEVzdGltYXRlIiwiUGVuZGluZ19lYWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIlBlbmRpbmdfc2V0RXN0aW1hdGVfZWFjaE9ic2VydmVyX3Rhc2siLCJ0aGVuYWJsZSIsIlRoZW5hYmxlX2luc3BlY3QiLCJjYXN0IiwiVGhlbmFibGVfY2FzdCIsIlRoZW5hYmxlX2Nhc3RfdGFzayIsIlRoZW5hYmxlX2Rpc3BhdGNoIiwiUGFzc2VkX2luc3BlY3QiLCJQYXNzZWRfZGlzcGF0Y2giLCJuaW52b2tlIiwiUV9uaW52b2tlIiwibWFrZU5vZGVSZXNvbHZlciIsIlByb21pc2Vfbmludm9rZSIsImRlbm9kZWlmeSIsIlFfZGVub2RlaWZ5IiwicGF0dGVybiIsImRlbm9kZWlmaWVkIiwidW5wYWNrIiwidmFyaWFkaWNOb2RlYmFja1RvUmVzb2x2ZXIiLCJuYW1lZEFyZ3VtZW50Tm9kZWJhY2tUb1Jlc29sdmVyIiwibm9kZWJhY2tUb1Jlc29sdmVyIiwibm9kZWlmeSIsIlByb21pc2Vfbm9kZWlmeSIsIm5vZGViYWNrIiwibmV4dFRpY2siLCJmdWxmaWxsIiwiaXNQcm9taXNlQWxpa2UiLCJmYWlsIiwiZmluIiwicHJvZ3Jlc3MiLCJtYXN0ZXIiLCJtYWtlUHJvbWlzZSIsInBvc3QiLCJtYXBwbHkiLCJzZW5kIiwiZGVsZXRlIiwibmVhcmVyIiwiZmFwcGx5IiwiZmNhbGwiLCJmYmluZCIsImZib3VuZCIsImNvbmNhdCIsIm5vdGlmeSIsIm1jYWxsIiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibnBvc3QiLCJubWFwcGx5IiwibnNlbmQiLCJubWNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/q/q.js\n");

/***/ })

};
;